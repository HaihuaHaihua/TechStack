# Cpp 基础

## 01 内存管理

### 1. C++ 中内存分配情况

栈区：由**编译器自动**管理分配和回收，存放**局部变量和函数参数**。

堆区：由**程序员手动**管理，需要手动通过代码 new malloc delete free 完成内存空间的分配和回收，空间较⼤，一般比较**复杂的数据类型**都是放在堆中，但可能会出现内存泄漏和空闲碎⽚的情况。

静态区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的**全局变量和静态变量**。（全局变量：出现在代码块{}之外的变量就是全局变量；静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。）

代码区：存放程序的**⼆进制代码**，这块内存在程序运行期间是不变的。

### 2. 堆和栈区别

**栈**

- 由**编译器自动管理**，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

- **连续的内存空间**，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，**不会产⽣碎⽚**。

- 栈是⾼地址向低地址扩展，栈低⾼地址，**空间较⼩**。

**堆**

- 由**程序员管理**，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

- **不连续的空间**，实际上系统中有⼀个空闲**链表**，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。

- 堆是低地址向⾼地址扩展，**空间交⼤**，较为灵活。

### 3. malloc / free 和 new / delete 的区别

**相同点：**

​	都可以⽤来在堆上分配和回收空间。

**不同点：**

- `malloc/free` 是 C/C++ 语言的标准**库函数**；`new/delete` 是 C++ 中的**运算符**。
- `malloc` 返回类型是 `void*`，使用时需要类型转换；而 `new` 的返回类型是指向**对象类型的指针**。
- `malloc/free`  只分配和回收**指定大小**的堆内存空间，而 `new/delete` 可以**根据对象类型**分配和回收合适的堆内存空间。
- 使用 `new/delete` 将调用构造函数或析构函数初始化或析构对象，而 `malloc/free` 没有该操作。

**new/delete 的执行过程：**

- 执⾏ new 实际上执⾏两个过程：
  - 分配未初始化的内存空间（malloc）。如果分配空间出现问题，则抛出 `std::bad_alloc` 异常，或被某个设定的异常处理函数捕获处理。
  - 使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在构造对象时出现异常，则⾃动调⽤ delete 释放内存。
- 执⾏ delete 实际上也有两个过程：
  - 使⽤析构函数对对象进⾏析构；
  - 回收内存空间（free）。

**为什么有了 malloc / free 还需要 new / delete？**

​	因为对于⾮内部数据类型（复杂数据结构）⽽⾔，光⽤ `malloc/free` ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。

​	由于 `mallo / free` 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务直接强加于 `malloc/free`，所以有了 `new / delete` 运算符对其进行进一步的扩展。

### 4. 什么是内存泄漏和内存溢出

**内存泄漏：**

​	内存泄漏简单的说就是申请了⼀块内存空间，**使⽤完毕后没有释放掉**，占用了有用内存。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

**内存溢出：**

​	内存溢出是指程序在申请内存时，**没有足够的内存空间供其使用**。内存泄漏的堆积最终会导致内存溢出内存溢出，就是程序申请的内存空间超过了系统实际可分配的空间，此时系统无法满足程序的需求，就会报内存溢出的错误。

**如何检测内存泄漏：**

- ⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
- 还可以使⽤其他⼀些 `/usr/bin/stat` ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
- 当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。

# 操作系统

## 操作系统基础

### 1. 操作系统的基本特点

**并发：**是在计算机系统中**同时存在多个程序**，宏观上看，这些程序是同时向前推进的。 在单CPU上，这些并发执行的程序是交替在CPU上运行的。程序并发性体现在两个方面： 用户程序与用户程序之间的并发执行。 用户程序与操作系统程序之间的并发。

**共享：**资源共享是操作系统程序和**多个用户程序共用系统中的资源**。

**虚拟：**是指通过技术**将一个物理实体变成若干个逻辑上的对应物**。在操作系统中虚拟的实现主要是通过分时的使用方法。显然，如果n是某一个物理设备所对应的虚拟逻辑设备数，则虚拟设备的速度必然是物理设备速度的1/n。

**异步（不确定性）：**同一程序和数据的**多次运行可能得到不同的结果**；程序的运行时间、运行顺序也具有不确定性；外部输入的请求、运行故障发生的时间难以预测。这些都是不确定性的表现。

**随机性：**是指操作系统的运行是在一个随机的环境中，一个设备可能在任何时间向处理机发出中断请求，系统无法知道运行着的程序会在什么时候做什么事情。

### 2. 并行与并发的区别

一个人"同时"做多件事，就是并发；多个人"同时"做多件事，就是并行

**并发：**指在同一时刻只能有一条指令执行，但多个进程指令被快速的**轮换执行**，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

**并行：**指在同一时刻，有多条指令在多个处理器上**同时执行**。所以无论从微观还是从宏观来看，二者都是一起执行的。

**并发与并行的区别：**

- 并发，指的是多个事情，在同一时间段内同时发生了；并行，指的是多个事情，在同一时间点上同时发生了。
- 并发的多个任务之间是互相抢占资源的；并行的多个任务之间是不互相抢占资源的。
- 只有在多CPU的情况中，才会发生并行；否则，看似同时发生的事情，其实都是并发执行的。

## 进程管理

### 1. 什么是进程

​	进程是**一个具有独立功能的程序关于某个数据集合的一次运行活动**。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是**资源分配的最小单位**，且每个进程拥有独立的地址空间。

### 2. 什么是线程

​	线程是进程的⼀个实体，是进程的⼀条执⾏路径；⽐进程更⼩的独⽴运⾏的基本单位，线程也被称为**轻量级进程**，是操作系统调度（CPU调度）执行的最小单位。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。

### 3. 进程与线程的区别

- 同⼀进程的线程**共享**本进程的系统资源（CPU时间片、内存等资源），⽽进程之间则是**独⽴**的系统资源
- 线程是 **CPU 调度**的最小单位，而进程是操作系统**分配资源**的最小单位
- **多进程⽐多线程健壮**：⼀个进程崩溃后，在保护模式下不会对其他进程产⽣影响，但是⼀个线程崩溃整个进程崩溃

- **多线程效率优于多进程**：进程切换，消耗的资源⼤，所以涉及到频繁的切换，使⽤线程要好于进程

- 每个独⽴的进程有⼀个程序的⼊⼝、程序出⼝。但是线程不能独⽴执⾏，必须依存在应⽤程序中，由应⽤程序提供多个线程执⾏控制。

**进程与线程联系的形象理解：**

​	进程和线程的关系类似于公路交通中的多向多车道公路，一个方向的公路视为一个**进程**，一个方向中多个车道线分割开的车道视为多个进程。一个方向的公路由一个或多个车道组成，他们共享道路资源，但不同方向的公路之间是相对独立的。这些不同方向和不同车道都可以**并发**运行，相同方向的不同车道间可以快捷协作同步，而不同方向中的不同车道则需要交通信号灯进行消息通行实现同步执行。

**进程与线程所占有的系统资源：**

线程 **私有**：线程栈，寄存器，程序寄存器 **共享**：堆，地址空间，全局变量，静态变量
进程 **私有**：地址空间，堆，全局变量，栈，寄存器 **共享**：代码段，公共数据，进程⽬录，进程ID

### 4. 线程的特点

- 线程在程序中是独⽴的、**并发的执⾏流**，但是进程中的线程之间的隔离程度要⼩；

- 线程⽐进程更具有**更⾼的性能**，这是由于同⼀个进程中的线程都有共性：多个线程将共享同⼀个进程虚拟空间；

- 当操作系统创建⼀个进程时，必须为进程分配独⽴的内存空间，并分配⼤量相关资源，而线程创建的**资源消耗要小**很多；

### 5. 多进程与多线程的区别

- **多进程⽐多线程健壮**：⼀个进程崩溃后，在保护模式下不会对其他进程产⽣影响，但是⼀个线程崩溃整个进程崩溃
- **多线程效率优于多进程**：进程切换，消耗的资源⼤，所以涉及到频繁的切换，使⽤线程要好于进程

**基于各自特点多进程和多线程有这不同的使用场景:**

1) 需要频繁创建销毁的优先⽤线程；
2) 需要进⾏⼤量计算的优先使⽤线程；
3) 强相关的处理⽤线程，弱相关的处理⽤进程；
4) 可能要扩展到多机分布的⽤进程，多核分布的⽤线程；

### 6. 什么是线程同步

​	线程同步是指多线程通过特定的设置来**控制**线程之间的**执⾏顺序**，也可以说在线程之间通过同步建⽴起执⾏顺序的关系；主要四种⽅式，**临界区、互斥对象、信号量、事件对象**；其中临界区和互斥对象主要⽤于**互斥控制**，信号量和事件对象主要⽤于**同步控制**。

### 7. 线程的同步方式

**互斥控制**

- 临界区：通过对多线程的串⾏化来访问公共资源或⼀段代码，速度快、适合控制数据访问。在**任意⼀个时刻只允许⼀个线程对共享资源进⾏访问**，如果有多个线程试图访问公共资源，那么在有⼀个线程进⼊后，其他试图访问公共资源的线程将被**挂起**，并⼀直等到进⼊临界区的线程离开，临界区在被释放后，其他线程才可以抢占。

- 互斥对象：互斥对象和临界区很像，采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。

**同步控制**

- 信号量：它允许多个线程在同⼀时刻访问同⼀资源，但是需要限制在同⼀时刻访问此资源的最⼤线程数⽬。在⽤ `CreateSemaphore()` 创建信号量时即要同时指出允许的最⼤资源计数和当前可⽤资源计数。⼀般是将当前可⽤资源计数设置为最⼤资源计数，每增加⼀个线程对共享资源的访问，当前可⽤资源计数就会减 1 ，只要当前可⽤资源计数是⼤于 0 的，就可以发出信号量信号。但是当前可⽤计数减⼩ 到0 时则说明当前占⽤资源的线程数已经达到了所允许的最⼤数⽬，不能在允许其他线程的进⼊，此时的信号量信号将⽆法发出。线程在处理完共享资源后，应在离开的同时通过`ReleaseSemaphore ()`函数将当前可⽤资源计数加1 。在任何时候当前可⽤资源计数决不可能⼤于
  最⼤资源计数。

- 事件对象：通过通知操作的⽅式来保持线程的同步，还可以⽅便实现对多个线程的优先级⽐较的操作。

### 8. 什么是线程安全

​	线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有**共享数据**的**多条**线程**并行执行**的程序中，线程安全的代码会通过**同步机制**保证各个线程都可以正常且**正确的执行**，不会出现数据污染等意外情况。没有**数据污染**，即每次程序运⾏结果和运⾏的结果是⼀样的，⽽且其他的变量的值也和预期的是⼀样的，这就是线程安全的。

​	线程不安全问题都是由**全局变量**及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，⽽⽆写操作，⼀般来说，这个全局变量是线程安全的；若有多个线程同时执⾏写操作，⼀般都需要有同步机制，否则的话就可能出现数据污染，从而影响线程安全。

### 9. 线程安全的实现方式

- **加锁**：利⽤ `Synchronized` 或者 `ReenTrantLock` 来对不安全对象进⾏加锁，来**实现线程执⾏的串⾏化**，从⽽保证多线程同时操作对象的安全性，⼀个是语法层⾯的**互斥锁**，⼀个是 `API` 层⾯的互斥锁。
- **⾮阻塞同步**。即先进性操作（**先到先得，冲突排队重试**），如果没有其他线程争⽤共享数据，那操作就成功了；如果共享数据有争⽤，产⽣冲突，那就再采取其他措施（最常⻅的措施就是不断地重试，知道成功为⽌）。这种⽅法需要硬件的⽀持，因为我们需要操作和冲突检测这两个步骤具备原⼦性。通常这种指令包括 `CASSC,FAI TAS` 等。
- **线程本地化**：⼀种⽆同步的⽅案，利⽤ `Threadlocal` 来为每⼀个线程创造⼀个**共享变量的副本**，避免⼏个线程同时操作⼀个对象时发⽣线程安全问题。

### 10. 进程间通信的方式

1) 管道
   管道，通常指⽆名管道。
   ① 半双⼯的，具有固定的读端和写端；
   ② 只能⽤于具有亲属关系的进程之间的通信；
   ③ 可以看成是⼀种特殊的⽂件，对于它的读写也可以使⽤普通的read、write函数。但是它不是普通的⽂件，并不
   属于其他任何⽂件系统，只能⽤于内存中。
   ④ Int pipe(int fd[2]);当⼀个管道建⽴时，会创建两个⽂件⽂件描述符，要关闭管道只需将这两个⽂件描述符关闭
   即可。
2) FiFO（有名管道）
   ① FIFO可以再⽆关的进程之间交换数据，与⽆名管道不同；
     ② FIFO有路径名与之相关联，它以⼀种特殊设备⽂件形式存在于⽂件系统中；
     ③ Int mkfifo(const char* pathname,mode_t mode);
3) 消息队列
   ① 消息队列，是消息的连接表，存放在内核中。⼀个消息队列由⼀个标识符来标识；
     ② 消息队列是⾯向记录的，其中的消息具有特定的格式以及特定的优先级；
     ③ 消息队列独⽴于发送与接收进程。进程终⽌时，消息队列及其内容并不会被删除；
     ④ 消息队列可以实现消息的随机查询
4) 信号量
   ① 信号量是⼀个计数器，信号量⽤于实现进程间的互斥与同步，⽽不是⽤于存储进程间通信数据；
     ② 信号量⽤于进程间同步，若要在进程间传递数据需要结合共享内存；
     ③ 信号量基于操作系统的PV操作，程序对信号量的操作都是原⼦操作；
5) 共享内存
   ① 共享内存，指两个或多个进程共享⼀个给定的存储区；
     ② 共享内存是最快的⼀种进程通信⽅式，因为进程是直接对内存进⾏存取；
     ③ 因为多个进程可以同时操作，所以需要进⾏同步；
     ④ 信号量+共享内存通常结合在⼀起使⽤。
6) 套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

# 计算机网络

## 计算机网络概述

### 1. OSI 七层协议模型

- **物理层**：简单的说，物理层（Physical Layer）确保原始的数据可在各种**物理媒体上传输**。在这⼀层上⾯规定了激活，维持，关闭通信端点之间的机械性，电⽓特性，功能特性，，为上层协议提供了⼀个传输数据的物理媒体，这⼀层传输的是 **bit 流**。IEEE 802.2
- **数据链路层**：数据链路层（Data Link Layer）在不可靠的物理介质上提供**可靠的传输**。该层的作⽤包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。这⼀层中将 bit 流封装成 **frame 帧**。ARP, MAC
- **⽹络层**：⽹络层（Network Layer）负责对⼦⽹间的数据包进⾏路由选择。此外，⽹络层还可以实现拥塞控制、⽹际互连等功能。在这⼀层，数据的单位称为**数据包**（packet）。IP
- **传输层**：传输层是第⼀个端到端，即主机到主机的层次。传输层负责**将上层数据分段并提供端到端的、可靠的或不可靠的传输**。此外，传输层还要处理端到端的差错控制和流量控制问题。在这⼀层，数据的单位称为**数据段**（segment）。TCP, UDP
- **会话层**：这⼀层管理主机之间的会话进程，即负责建⽴、管理、终⽌进程之间的会话。会话层还利⽤在数据中插⼊校验点来实现数据的同步，访问验证和会话管理在内的建⽴和维护应⽤之间通信的机制。如**服务器验证⽤户登录便是由会话层完成的**。使通信会话在通信失效时从校验点继续恢复通信。⽐如说**建⽴会话**，如 session 认证、断点续传。DNS
- **表示层**：这⼀层主要解决⽤户信息的语法表示问题。它将欲交换的数据从适合于某⼀⽤户的抽象语法，转换为适合于 OSI 系统内部使⽤的传送语法。即**提供格式化的表示和转换数据服务**。数据的压缩和解压缩， 加密和解密等⼯作都由表示层负责。⽐如说图像、视频编码解，数据加密。 Telnet
- **应⽤层**：这⼀层为操作系统或⽹络应⽤程序**提供访问⽹络服务的接⼝**。HTTP

## 运输层

### 1. **UDP 与 TCP 的区别**

**用户数据报协议 UDP（User Datagram Protocol）**

- 是**无连接**的，
- 尽最大可能交付，即**不可靠交付**
- **没有拥塞控制**，源主机以恒定的速率发送数据
- **面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），
- 支持一对一、一对多、多对一和**多对多**的交互通信
- 首部开销小

**传输控制协议 TCP（Transmission Control Protocol）**

- 是**面向连接**的，
- 提供**可靠交付**，
- **有**流量控制，拥塞控制，
- **面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），
- 每一条 TCP 连接只能是点对点的（**一对一**），
- 提供**全双工通信**，TCP 连接的两端在任何时候都可以发送和接收数据

### 2. TCP 报文段的首部格式

- **源端口**和**目的端口**（16bit+16bit）：源端口号和目的端口号
- **序号**（32bit）：传输⽅向上字节流的字节编号。初始时序号会被设置⼀个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第⼀段数据512字节已经到B，则第⼆段数据发送时序号为1024 + 512。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的**每一个字节都按顺序编号**，**⽤于解决⽹络包乱序问题**。
- **确认号**（32bit）：接收⽅对发送⽅ TCP 报⽂段的响应，其值是收到的序号值 + 1。确认号 = N，表示到序号 N-1 为止都所有数据都已经正确收到，期望收到发送方的下一个报文断的第一个数据字节的序号为 N。
- **数据偏移**（4bit）：报文段数据起始处距离整个报文段起始处的距离即**首部长度**，标识⾸部有多少个4字节 * ⾸部⻓，最⼤为15，即60字节。
- **标志位**（6bit）：
  - 紧急 URG（urgent）：标志紧急指针是否有效。
  - 确认 ACK（acknowledgment）：标志确认号是否有效（确认报⽂段）。⽤于**解决丢包**问题。
  - 推送 PSH（push）：提示接收端⽴即从**缓冲读⾛**数据。
  - 复位 RST（reset）：表示要求对⽅**重新建⽴**连接（复位报⽂段）。
  - 同步 SYN（synchronization）：表示请求**建⽴**⼀个连接（连接报⽂段）。
  - 终止 FIN（finish）：表示**关闭连接**（断开报⽂段）。
- **窗⼝**（16bit）：接收窗⼝。⽤于告知对⽅（发送⽅）本⽅的**缓冲**还能接收多少字节数据。⽤于**流量控制**。
- **校验和**（16bit）：接收端⽤ CRC 检验整个报⽂段有⽆**损坏**。

### 3. TCP 三次握手

1. 客户端 SYN-SENT ：客户端发含 `SYN = 1, seq = x` 的建立连接包到服务器
2. 服务器 SYN-RCVD：服务器发含 `SYN = 1, ACK = 1, seq = y, ack = x+1` 的建立连接包到客户端
3. 客户端 ESTABLISHED：客户端发含 `ACK = 1, seq = x+1, ack = y+1` 的确认包到服务器，服务器 ESTABLISHED

### 4. TCP 四次挥手

1. 客户端 FIN-WAIT-1：客户端发送 `FIN = 1, seq = u` 的关闭连接包到服务器
2. 服务器 CLOSE-WAIT：服务器发送 `ACK = 1, seq = v, ack = u+1` 的确认包到客户端。这两步完成了客户端的连接关闭，客户端进入 FIN-WAIT-2 状态。此时整个连接处于**半关闭状态**，服务器还未释放连接，若服务器这段时间内向客户端发送数据，客户端仍要接收。
3. 服务器 CLOSE-WAIT：服务器发送 `FIN = 1, ACK = 1, seq = w, ack = u+1` 的关闭连接包到客户端。
4. 客户端 FIN-WAIT-2：客户端发送 `ACK = 1, seq = u+1, ack = w+1` 的确认包到服务器。3、4 两步完成了服务器的连接关闭，在此之后客户端进入持续 2MSL 的时间等待状态 TIME-WAIT。(`MSL (Maximum Segment Lifetime)`，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。)

### 5. 为什么客户端在 TIME-WAIT 状态等待 2MSL ？

- **保证连接正确关闭**：等待足够的时间以确保最后的 ACK 能让服务器接收。因为客户端发送的确认包可能丢失，服务端在 LAST-ACK 状态收不到确认包时会进行超时重传关闭连接包给客户端，这时就能保证客户端在 2MSL 的等待时间内重传一次确认包，保证服务器正确关闭连接。如果客户端仅发完确认包后不仅入时间等待状态，而是立即释放连接，则无法收到服务器重传的关闭连接包，导致其无法正确关闭连接。
- **防止已失效的连接请求报文段出现在本连接中**：`2MSL` 的时间等待足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。如果没有时间等待状态，将使得具备相同序号的旧连接被接收，导致数据错乱。

### 6. TCP 的连接状态

![TCP连接](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP连接.png)

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端 socket 执⾏CONNECT连接，发送SYN包，进⼊此状态。
- SYN_RECV：服务端收到 SYN 包并发送服务端 SYN 包，进⼊此状态。
- ESTABLISH：表示连接建⽴。客户端发送了最后⼀个ACK包后进⼊此状态，服务端接收到ACK包后进⼊此状态。
- FIN_WAIT_1：终⽌连接的⼀⽅（通常是客户机）发送了FIN报⽂后进⼊。等待对⽅FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对⽅的FIN包之后，⾃然是需要⽴即回复ACK包的，表示已经知道断开请求。但是本⽅是否⽴即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送 FIN 包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的ACK包，但并没有⽴即接收到服务端的FIN包，进⼊FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进⼊此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

### 7. TCP 四次挥手中的等待状态

- FIN_WAIT_1：客户端发送了 FIN 报⽂后进⼊ FIN_WAIT_1 状态，并等待服务器确认。
- FIN_WAIT_2：
  - 此时是**半关闭状态**，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的 ACK 包，但并没有⽴即接收到服务端的FIN包，进⼊ FIN_WAIT_2 状态。
  - 该状态中**服务器还未释放连接**，若服务器这段时间内向客户端发送数据，客户端仍要接收，但是已经没有发送数据能力。
- CLOSE_WAIT：发出被动关闭连接确认报文段之后，发出主动关闭连接报文段之前处于的状态。
  - 被动关闭连接⼀⽅接收到 FIN 包会⽴即回应 ACK 包表示已接收到断开请求。
  - 被动关闭连接⼀⽅如果还有**剩余数据要发送**就会进⼊ CLOSED_WAIT 状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。
  - 如果客户端直接进⼊CLOSED状态，如果服务端没有接收到最后⼀次ACK包会在超时之后重新再发 FIN 包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK⽽是收到RST。所 TIME_WAIT 状态⽬的是防⽌最后⼀次握⼿数据没有到达对⽅⽽触发重传FIN准备的。
  - 在 2MSL 时间内，同⼀个socket不能再被使⽤，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。

### 8. 为什么握⼿是三次，挥⼿是四次

- 对于握⼿：握⼿只需要确认双⽅通信时的初始化序号，保证通信不会乱序。（**第三次握⼿**必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同⼀个客户机保持多个连接，造成资源浪费。）
- 对于挥⼿：TCP 是**全双⼯通信**的，所以发送⽅和接收⽅都需要 FIN 和 ACK。只不过有⼀⽅是被动的，所以看上去就成了4次挥⼿。

### 9. 什么是超时重传、RTT 和 RTO

- **超时重传：**发送端发送报⽂后若**⻓时间未收到确认**的报⽂则需要重发该报⽂。可能有以下⼏种情况：
  - 发送的数据没能到达接收端，所以对⽅没有响应
  - 接收端接收到数据，但是ACK报⽂在返回过程中丢失
  - 接收端拒绝或丢弃数据
- **报文段的往返时间 RTT：** 数据从发送到接收到对⽅响应之间的时间间隔，即数据报在⽹络中**⼀个往返⽤时**，其⼤⼩不稳定。
- **超时重传时间 RTO：**从上⼀次发送数据，因为⻓期没有收到 ACK 响应，到下⼀次重发之间的时间，就是**重传间隔**。
  - 通常每次重传RTO是前⼀次重传间隔的两倍，计量单位通常是 RTT，例：1RTT，2RTT，4RTT，
    8RTT......
  - 重传次数到达上限之后停⽌重传

### 10. TCP 滑动窗口

- TCP是双⼯协议，双⽅可以同时通信，所以发送⽅接收⽅各⾃维护⼀个**发送窗和接收窗**。
  - 发送窗：⽤来限制发送⽅可以发送的数据⼤⼩，其中发送窗⼝的⼤⼩由接收端返回的TCP报⽂段中窗⼝字段来控制，接收⽅通过此字段告知发送⽅⾃⼰的缓冲（受系统、硬件等限制）⼤⼩。
  - 接收窗：⽤来标记可以接收的数据⼤⼩。
- TCP 是流数据
  - 发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | **已发送未被确认部分 | 未发送但可发送部分** | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。
  - 接收到的数据流可分为：已接收 | **未接收但准备接收** | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
- 发送窗内数据只有当接收到接收端某段发送数据的 ACK 响应时才移动发送窗，**左边缘**紧贴刚被确认的数据。接收窗也只有接收到数据且**最左侧**连续时才移动接收窗⼝。

### 11. 什么是流量控制

​	流量控制⽬的是接收⽅通过 TCP 头窗⼝字段告知发送⽅本⽅可接收的最⼤数据量，⽤以**解决发送速率过快导致接收⽅不能接收的问题**，所以流量控制是**点对点控制**。

### 12. 什么是拥塞控制

​	拥塞控制⽬的是防⽌数据被过多注⽹络中导致⽹络资源（路由器、交换机等）过载。因为拥塞控制涉及⽹络链路全局，所以属于**全局控制**，控制拥塞使⽤拥塞窗⼝。

### 13. TCP 的拥塞控制算法

TCP 主要通过四个算法来进行拥塞控制：

**慢开始**：cwnd  = 1, 每个轮次 cwnd 加倍增长

**拥塞避免**：cwnd >= ssthresh, cwnd 线性增长，每个轮次只将 cwnd 加 1

**快重传**：三个重复确认立即重传丢失的报文段

**快恢复**：ssthresh = cwnd / 2, cwnd = ssthresh

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

![TCP拥塞控制](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP拥塞控制.jpg)

**慢开始与拥塞避免**

发送的最初执行**慢开始，令 cwnd = 1**，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到**慢开始每个轮次都将 cwnd 加倍**，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。

设置一个**慢开始门限 ssthresh**，当 cwnd >= ssthresh 时，进入**拥塞避免，每个轮次只将 cwnd 加 1**。

如果出现了**超时**，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到**三个重复确认**，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而**快恢复 cwnd 设定为 ssthresh**。

<img src="/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP快重传.jpg" alt="TCP快重传" style="zoom:67%;" />

**超时与3ACK**

- 超时：判断为出现网络拥塞，令 **ssthresh = cwnd / 2**，然后重新执行慢开始 **cwnd = 1**
- 3ACK：三个重复确认避免判断为超时情况，发送方也就不会误认为出现了网络拥塞，这时执行快重传立即重传丢失的报文段，接着执行快恢复令 **ssthresh = cwnd / 2 ，cwnd = ssthresh**，避免直接判断为拥塞情况重新执行慢开始降低传输效率。

**慢开始门限用法**

- cwnd < ssthresh : 执行慢开始
- cwnd > ssthresh : 停止慢开始 指向拥塞避免
- cwnd = ssthresh : 可以使用慢开始，也可以使用拥塞避免

### 14. TCP 如何实现提供可靠数据传输

- 建⽴连接（标志位）：通信前确认通信实体存在。
- 序号机制（序号、确认号）：确保了数据是按序、完整到达。
- 数据校验（校验和）：CRC 校验全部数据。
- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
- 窗⼝机制（窗⼝）：提供流量控制，避免过量发送。
- 拥塞控制：提供拥塞控制，避免网络拥塞。

## 应用层

