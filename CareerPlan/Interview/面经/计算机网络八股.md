## 计算机网络概述

### 1. OSI 七层协议模型

- **物理层**：简单的说，物理层（Physical Layer）确保原始的数据可在各种**物理媒体上传输**。在这⼀层上⾯规定了激活，维持，关闭通信端点之间的机械性，电⽓特性，功能特性，，为上层协议提供了⼀个传输数据的物理媒体，这⼀层传输的是 **bit 流**。IEEE 802.2
- **数据链路层**：数据链路层（Data Link Layer）在不可靠的物理介质上提供**可靠的传输**。该层的作⽤包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。这⼀层中将 bit 流封装成 **frame 帧**。ARP, MAC
- **⽹络层**：⽹络层（Network Layer）负责对⼦⽹间的数据包进⾏路由选择。此外，⽹络层还可以实现拥塞控制、⽹际互连等功能。在这⼀层，数据的单位称为**数据包**（packet）。IP
- **传输层**：传输层是第⼀个端到端，即主机到主机的层次。传输层负责**将上层数据分段并提供端到端的、可靠的或不可靠的传输**。此外，传输层还要处理端到端的差错控制和流量控制问题。在这⼀层，数据的单位称为**数据段**（segment）。TCP, UDP
- **会话层**：这⼀层管理主机之间的会话进程，即负责建⽴、管理、终⽌进程之间的会话。会话层还利⽤在数据中插⼊校验点来实现数据的同步，访问验证和会话管理在内的建⽴和维护应⽤之间通信的机制。如**服务器验证⽤户登录便是由会话层完成的**。使通信会话在通信失效时从校验点继续恢复通信。⽐如说**建⽴会话**，如 session 认证、断点续传。DNS
- **表示层**：这⼀层主要解决⽤户信息的语法表示问题。它将欲交换的数据从适合于某⼀⽤户的抽象语法，转换为适合于 OSI 系统内部使⽤的传送语法。即**提供格式化的表示和转换数据服务**。数据的压缩和解压缩， 加密和解密等⼯作都由表示层负责。⽐如说图像、视频编码解，数据加密。 Telnet
- **应⽤层**：这⼀层为操作系统或⽹络应⽤程序**提供访问⽹络服务的接⼝**。HTTP

## 运输层

### 1. **UDP 与 TCP 的区别**

**用户数据报协议 UDP（User Datagram Protocol）**

- 是**无连接**的，
- 尽最大可能交付，即**不可靠交付**
- **没有拥塞控制**，源主机以恒定的速率发送数据
- **面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），
- 支持一对一、一对多、多对一和**多对多**的交互通信
- 首部开销小

**传输控制协议 TCP（Transmission Control Protocol）**

- 是**面向连接**的，
- 提供**可靠交付**，
- **有**流量控制，拥塞控制，
- **面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），
- 每一条 TCP 连接只能是点对点的（**一对一**），
- 提供**全双工通信**，TCP 连接的两端在任何时候都可以发送和接收数据

### 2. TCP 报文段的首部格式

- **源端口**和**目的端口**（16bit+16bit）：源端口号和目的端口号
- **序号**（32bit）：传输⽅向上字节流的字节编号。初始时序号会被设置⼀个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第⼀段数据512字节已经到B，则第⼆段数据发送时序号为1024 + 512。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的**每一个字节都按顺序编号**，**⽤于解决⽹络包乱序问题**。
- **确认号**（32bit）：接收⽅对发送⽅ TCP 报⽂段的响应，其值是收到的序号值 + 1。确认号 = N，表示到序号 N-1 为止都所有数据都已经正确收到，期望收到发送方的下一个报文断的第一个数据字节的序号为 N。
- **数据偏移**（4bit）：报文段数据起始处距离整个报文段起始处的距离即**首部长度**，标识⾸部有多少个4字节 * ⾸部⻓，最⼤为15，即60字节。
- **标志位**（6bit）：
  - 紧急 URG（urgent）：标志紧急指针是否有效。
  - 确认 ACK（acknowledgment）：标志确认号是否有效（确认报⽂段）。⽤于**解决丢包**问题。
  - 推送 PSH（push）：提示接收端⽴即从**缓冲读⾛**数据。
  - 复位 RST（reset）：表示要求对⽅**重新建⽴**连接（复位报⽂段）。
  - 同步 SYN（synchronization）：表示请求**建⽴**⼀个连接（连接报⽂段）。
  - 终止 FIN（finish）：表示**关闭连接**（断开报⽂段）。
- **窗⼝**（16bit）：接收窗⼝。⽤于告知对⽅（发送⽅）本⽅的**缓冲**还能接收多少字节数据。⽤于**流量控制**。
- **校验和**（16bit）：接收端⽤ CRC 检验整个报⽂段有⽆**损坏**。

### 3. TCP 三次握手

1. 客户端 SYN-SENT ：客户端发含 `SYN = 1, seq = x` 的建立连接包到服务器
2. 服务器 SYN-RCVD：服务器发含 `SYN = 1, ACK = 1, seq = y, ack = x+1` 的建立连接包到客户端
3. 客户端 ESTABLISHED：客户端发含 `ACK = 1, seq = x+1, ack = y+1` 的确认包到服务器，服务器 ESTABLISHED

### 4. TCP 四次挥手

1. 客户端 FIN-WAIT-1：客户端发送 `FIN = 1, seq = u` 的关闭连接包到服务器
2. 服务器 CLOSE-WAIT：服务器发送 `ACK = 1, seq = v, ack = u+1` 的确认包到客户端。这两步完成了客户端的连接关闭，客户端进入 FIN-WAIT-2 状态。此时整个连接处于**半关闭状态**，服务器还未释放连接，若服务器这段时间内向客户端发送数据，客户端仍要接收。
3. 服务器 CLOSE-WAIT：服务器发送 `FIN = 1, ACK = 1, seq = w, ack = u+1` 的关闭连接包到客户端。
4. 客户端 FIN-WAIT-2：客户端发送 `ACK = 1, seq = u+1, ack = w+1` 的确认包到服务器。3、4 两步完成了服务器的连接关闭，在此之后客户端进入持续 2MSL 的时间等待状态 TIME-WAIT。(`MSL (Maximum Segment Lifetime)`，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。)

### 5. 为什么客户端在 TIME-WAIT 状态等待 2MSL ？

- **保证连接正确关闭**：等待足够的时间以确保最后的 ACK 能让服务器接收。因为客户端发送的确认包可能丢失，服务端在 LAST-ACK 状态收不到确认包时会进行超时重传关闭连接包给客户端，这时就能保证客户端在 2MSL 的等待时间内重传一次确认包，保证服务器正确关闭连接。如果客户端仅发完确认包后不仅入时间等待状态，而是立即释放连接，则无法收到服务器重传的关闭连接包，导致其无法正确关闭连接。
- **防止已失效的连接请求报文段出现在本连接中**：`2MSL` 的时间等待足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。如果没有时间等待状态，将使得具备相同序号的旧连接被接收，导致数据错乱。

### 6. TCP 的连接状态

![TCP连接](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP连接.png)

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端 socket 执⾏CONNECT连接，发送SYN包，进⼊此状态。
- SYN_RECV：服务端收到 SYN 包并发送服务端 SYN 包，进⼊此状态。
- ESTABLISH：表示连接建⽴。客户端发送了最后⼀个ACK包后进⼊此状态，服务端接收到ACK包后进⼊此状态。
- FIN_WAIT_1：终⽌连接的⼀⽅（通常是客户机）发送了FIN报⽂后进⼊。等待对⽅FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对⽅的FIN包之后，⾃然是需要⽴即回复ACK包的，表示已经知道断开请求。但是本⽅是否⽴即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送 FIN 包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的ACK包，但并没有⽴即接收到服务端的FIN包，进⼊FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进⼊此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

### 7. TCP 四次挥手中的等待状态

- FIN_WAIT_1：客户端发送了 FIN 报⽂后进⼊ FIN_WAIT_1 状态，并等待服务器确认。
- FIN_WAIT_2：
  - 此时是**半关闭状态**，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的 ACK 包，但并没有⽴即接收到服务端的FIN包，进⼊ FIN_WAIT_2 状态。
  - 该状态中**服务器还未释放连接**，若服务器这段时间内向客户端发送数据，客户端仍要接收，但是已经没有发送数据能力。
- CLOSE_WAIT：发出被动关闭连接确认报文段之后，发出主动关闭连接报文段之前处于的状态。
  - 被动关闭连接⼀⽅接收到 FIN 包会⽴即回应 ACK 包表示已接收到断开请求。
  - 被动关闭连接⼀⽅如果还有**剩余数据要发送**就会进⼊ CLOSED_WAIT 状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。
  - 如果客户端直接进⼊CLOSED状态，如果服务端没有接收到最后⼀次ACK包会在超时之后重新再发 FIN 包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK⽽是收到RST。所 TIME_WAIT 状态⽬的是防⽌最后⼀次握⼿数据没有到达对⽅⽽触发重传FIN准备的。
  - 在 2MSL 时间内，同⼀个socket不能再被使⽤，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。

### 8. 为什么握⼿是三次，挥⼿是四次

- 对于握⼿：握⼿只需要确认双⽅通信时的初始化序号，保证通信不会乱序。（**第三次握⼿**必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同⼀个客户机保持多个连接，造成资源浪费。）
- 对于挥⼿：TCP 是**全双⼯通信**的，所以发送⽅和接收⽅都需要 FIN 和 ACK。只不过有⼀⽅是被动的，所以看上去就成了4次挥⼿。

### 9. 什么是超时重传、RTT 和 RTO

- **超时重传：**发送端发送报⽂后若**⻓时间未收到确认**的报⽂则需要重发该报⽂。可能有以下⼏种情况：
  - 发送的数据没能到达接收端，所以对⽅没有响应
  - 接收端接收到数据，但是ACK报⽂在返回过程中丢失
  - 接收端拒绝或丢弃数据
- **报文段的往返时间 RTT：** 数据从发送到接收到对⽅响应之间的时间间隔，即数据报在⽹络中**⼀个往返⽤时**，其⼤⼩不稳定。
- **超时重传时间 RTO：**从上⼀次发送数据，因为⻓期没有收到 ACK 响应，到下⼀次重发之间的时间，就是**重传间隔**。
  - 通常每次重传RTO是前⼀次重传间隔的两倍，计量单位通常是 RTT，例：1RTT，2RTT，4RTT，
    8RTT......
  - 重传次数到达上限之后停⽌重传

### 10. TCP 滑动窗口

- TCP是双⼯协议，双⽅可以同时通信，所以发送⽅接收⽅各⾃维护⼀个**发送窗和接收窗**。
  - 发送窗：⽤来限制发送⽅可以发送的数据⼤⼩，其中发送窗⼝的⼤⼩由接收端返回的TCP报⽂段中窗⼝字段来控制，接收⽅通过此字段告知发送⽅⾃⼰的缓冲（受系统、硬件等限制）⼤⼩。
  - 接收窗：⽤来标记可以接收的数据⼤⼩。
- TCP 是流数据
  - 发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | **已发送未被确认部分 | 未发送但可发送部分** | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。
  - 接收到的数据流可分为：已接收 | **未接收但准备接收** | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
- 发送窗内数据只有当接收到接收端某段发送数据的 ACK 响应时才移动发送窗，**左边缘**紧贴刚被确认的数据。接收窗也只有接收到数据且**最左侧**连续时才移动接收窗⼝。

### 11. 什么是流量控制

​	流量控制⽬的是接收⽅通过 TCP 头窗⼝字段告知发送⽅本⽅可接收的最⼤数据量，⽤以**解决发送速率过快导致接收⽅不能接收的问题**，所以流量控制是**点对点控制**。

### 12. 什么是拥塞控制

​	拥塞控制⽬的是防⽌数据被过多注⽹络中导致⽹络资源（路由器、交换机等）过载。因为拥塞控制涉及⽹络链路全局，所以属于**全局控制**，控制拥塞使⽤拥塞窗⼝。

### 13. TCP 的拥塞控制算法

TCP 主要通过四个算法来进行拥塞控制：

**慢开始**：cwnd  = 1, 每个轮次 cwnd 加倍增长

**拥塞避免**：cwnd >= ssthresh, cwnd 线性增长，每个轮次只将 cwnd 加 1

**快重传**：三个重复确认立即重传丢失的报文段

**快恢复**：ssthresh = cwnd / 2, cwnd = ssthresh

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

![TCP拥塞控制](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP拥塞控制.jpg)

**慢开始与拥塞避免**

发送的最初执行**慢开始，令 cwnd = 1**，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到**慢开始每个轮次都将 cwnd 加倍**，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。

设置一个**慢开始门限 ssthresh**，当 cwnd >= ssthresh 时，进入**拥塞避免，每个轮次只将 cwnd 加 1**。

如果出现了**超时**，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到**三个重复确认**，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而**快恢复 cwnd 设定为 ssthresh**。

<img src="/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP快重传.jpg" alt="TCP快重传" style="zoom:67%;" />

**超时与3ACK**

- 超时：判断为出现网络拥塞，令 **ssthresh = cwnd / 2**，然后重新执行慢开始 **cwnd = 1**
- 3ACK：三个重复确认避免判断为超时情况，发送方也就不会误认为出现了网络拥塞，这时执行快重传立即重传丢失的报文段，接着执行快恢复令 **ssthresh = cwnd / 2 ，cwnd = ssthresh**，避免直接判断为拥塞情况重新执行慢开始降低传输效率。

**慢开始门限用法**

- cwnd < ssthresh : 执行慢开始
- cwnd > ssthresh : 停止慢开始 指向拥塞避免
- cwnd = ssthresh : 可以使用慢开始，也可以使用拥塞避免

### 14. TCP 如何实现提供可靠数据传输

- 建⽴连接（标志位）：通信前确认通信实体存在。
- 序号机制（序号、确认号）：确保了数据是按序、完整到达。
- 数据校验（校验和）：CRC 校验全部数据。
- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
- 窗⼝机制（窗⼝）：提供流量控制，避免过量发送。
- 拥塞控制：提供拥塞控制，避免网络拥塞。

## 应用层

