## 计算机网络概述

### 1. OSI 七层协议模型

- **物理层**：简单的说，物理层（Physical Layer）确保原始的数据可在各种**物理媒体上传输**。在这⼀层上⾯规定了激活，维持，关闭通信端点之间的机械性，电⽓特性，功能特性，，为上层协议提供了⼀个传输数据的物理媒体，这⼀层传输的是 **bit 流**。IEEE 802.2
- **数据链路层**：数据链路层（Data Link Layer）在不可靠的物理介质上提供**可靠的传输**。该层的作⽤包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。这⼀层中将 bit 流封装成 **frame 帧**。ARP, MAC
- **⽹络层**：⽹络层（Network Layer）负责对⼦⽹间的数据包进⾏路由选择。此外，⽹络层还可以实现拥塞控制、⽹际互连等功能。在这⼀层，数据的单位称为**数据包**（packet）。IP
- **传输层**：传输层是第⼀个端到端，即主机到主机的层次。传输层负责**将上层数据分段并提供端到端的、可靠的或不可靠的传输**。此外，传输层还要处理端到端的差错控制和流量控制问题。在这⼀层，数据的单位称为**数据段**（segment）。TCP, UDP
- **会话层**：这⼀层管理主机之间的会话进程，即负责建⽴、管理、终⽌进程之间的会话。会话层还利⽤在数据中插⼊校验点来实现数据的同步，访问验证和会话管理在内的建⽴和维护应⽤之间通信的机制。如**服务器验证⽤户登录便是由会话层完成的**。使通信会话在通信失效时从校验点继续恢复通信。⽐如说**建⽴会话**，如 session 认证、断点续传。DNS
- **表示层**：这⼀层主要解决⽤户信息的语法表示问题。它将欲交换的数据从适合于某⼀⽤户的抽象语法，转换为适合于 OSI 系统内部使⽤的传送语法。即**提供格式化的表示和转换数据服务**。数据的压缩和解压缩， 加密和解密等⼯作都由表示层负责。⽐如说图像、视频编码解，数据加密。 Telnet
- **应⽤层**：这⼀层为操作系统或⽹络应⽤程序**提供访问⽹络服务的接⼝**。HTTP

## 运输层

### 1. **UDP 与 TCP 的区别**

**用户数据报协议 UDP（User Datagram Protocol）**

- 是**无连接**的，
- 尽最大可能交付，即**不可靠交付**
- **没有拥塞控制**，源主机以恒定的速率发送数据
- **面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），
- 支持一对一、一对多、多对一和**多对多**的交互通信
- 首部开销小

**传输控制协议 TCP（Transmission Control Protocol）**

- 是**面向连接**的，
- 提供**可靠交付**，
- **有**流量控制，拥塞控制，
- **面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），
- 每一条 TCP 连接只能是点对点的（**一对一**），
- 提供**全双工通信**，TCP 连接的两端在任何时候都可以发送和接收数据

### 2. TCP 报文段的首部格式

- **源端口**和**目的端口**（16bit+16bit）：源端口号和目的端口号
- **序号**（32bit）：传输⽅向上字节流的字节编号。初始时序号会被设置⼀个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第⼀段数据512字节已经到B，则第⼆段数据发送时序号为1024 + 512。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的**每一个字节都按顺序编号**，**⽤于解决⽹络包乱序问题**。
- **确认号**（32bit）：接收⽅对发送⽅ TCP 报⽂段的响应，其值是收到的序号值 + 1。确认号 = N，表示到序号 N-1 为止都所有数据都已经正确收到，期望收到发送方的下一个报文断的第一个数据字节的序号为 N。
- **数据偏移**（4bit）：报文段数据起始处距离整个报文段起始处的距离即**首部长度**，标识⾸部有多少个4字节 * ⾸部⻓，最⼤为15，即60字节。
- **标志位**（6bit）：
  - 紧急 URG（urgent）：标志紧急指针是否有效。
  - 确认 ACK（acknowledgment）：标志确认号是否有效（确认报⽂段）。⽤于**解决丢包**问题。
  - 推送 PSH（push）：提示接收端⽴即从**缓冲读⾛**数据。
  - 复位 RST（reset）：表示要求对⽅**重新建⽴**连接（复位报⽂段）。
  - 同步 SYN（synchronization）：表示请求**建⽴**⼀个连接（连接报⽂段）。
  - 终止 FIN（finish）：表示**关闭连接**（断开报⽂段）。
- **窗⼝**（16bit）：接收窗⼝。⽤于告知对⽅（发送⽅）本⽅的**缓冲**还能接收多少字节数据。⽤于**流量控制**。
- **校验和**（16bit）：接收端⽤ CRC 检验整个报⽂段有⽆**损坏**。

### 3. TCP 三次握手

1. 客户端 SYN-SENT ：客户端发含 `SYN = 1, seq = x` 的建立连接包到服务器
2. 服务器 SYN-RCVD：服务器发含 `SYN = 1, ACK = 1, seq = y, ack = x+1` 的建立连接包到客户端
3. 客户端 ESTABLISHED：客户端发含 `ACK = 1, seq = x+1, ack = y+1` 的确认包到服务器，服务器 ESTABLISHED

### 4. TCP 四次挥手

1. 客户端 FIN-WAIT-1：客户端发送 `FIN = 1, seq = u` 的关闭连接包到服务器
2. 服务器 CLOSE-WAIT：服务器发送 `ACK = 1, seq = v, ack = u+1` 的确认包到客户端。这两步完成了客户端的连接关闭，客户端进入 FIN-WAIT-2 状态。此时整个连接处于**半关闭状态**，服务器还未释放连接，若服务器这段时间内向客户端发送数据，客户端仍要接收。
3. 服务器 CLOSE-WAIT：服务器发送 `FIN = 1, ACK = 1, seq = w, ack = u+1` 的关闭连接包到客户端。
4. 客户端 FIN-WAIT-2：客户端发送 `ACK = 1, seq = u+1, ack = w+1` 的确认包到服务器。3、4 两步完成了服务器的连接关闭，在此之后客户端进入持续 2MSL 的时间等待状态 TIME-WAIT。(`MSL (Maximum Segment Lifetime)`，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。)

### 5. 为什么客户端在 TIME-WAIT 状态等待 2MSL ？

- **保证连接正确关闭**：等待足够的时间以确保最后的 ACK 能让服务器接收。因为客户端发送的确认包可能丢失，服务端在 LAST-ACK 状态收不到确认包时会进行超时重传关闭连接包给客户端，这时就能保证客户端在 2MSL 的等待时间内重传一次确认包，保证服务器正确关闭连接。如果客户端仅发完确认包后不仅入时间等待状态，而是立即释放连接，则无法收到服务器重传的关闭连接包，导致其无法正确关闭连接。
- **防止已失效的连接请求报文段出现在本连接中**：`2MSL` 的时间等待足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。如果没有时间等待状态，将使得具备相同序号的旧连接被接收，导致数据错乱。

### 6. TCP 的连接状态

![TCP连接](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP连接.png)

- CLOSED：初始状态。
- LISTEN：服务器处于监听状态。
- SYN_SEND：客户端 socket 执⾏CONNECT连接，发送SYN包，进⼊此状态。
- SYN_RECV：服务端收到 SYN 包并发送服务端 SYN 包，进⼊此状态。
- ESTABLISH：表示连接建⽴。客户端发送了最后⼀个ACK包后进⼊此状态，服务端接收到ACK包后进⼊此状态。
- FIN_WAIT_1：终⽌连接的⼀⽅（通常是客户机）发送了FIN报⽂后进⼊。等待对⽅FIN。
- CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对⽅的FIN包之后，⾃然是需要⽴即回复ACK包的，表示已经知道断开请求。但是本⽅是否⽴即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送 FIN 包之前均为此状态。
- FIN_WAIT_2：此时是半连接状态，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的ACK包，但并没有⽴即接收到服务端的FIN包，进⼊FIN_WAIT_2状态。
- LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进⼊此状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。

### 7. TCP 四次挥手中的等待状态

- FIN_WAIT_1：客户端发送了 FIN 报⽂后进⼊ FIN_WAIT_1 状态，并等待服务器确认。
- FIN_WAIT_2：
  - 此时是**半关闭状态**，即有⼀⽅要求关闭连接，等待另⼀⽅关闭。客户端接收到服务器的 ACK 包，但并没有⽴即接收到服务端的FIN包，进⼊ FIN_WAIT_2 状态。
  - 该状态中**服务器还未释放连接**，若服务器这段时间内向客户端发送数据，客户端仍要接收，但是已经没有发送数据能力。
- CLOSE_WAIT：发出被动关闭连接确认报文段之后，发出主动关闭连接报文段之前处于的状态。
  - 被动关闭连接⼀⽅接收到 FIN 包会⽴即回应 ACK 包表示已接收到断开请求。
  - 被动关闭连接⼀⽅如果还有**剩余数据要发送**就会进⼊ CLOSED_WAIT 状态。
- TIME_WAIT：客户端收到服务端的FIN包，并⽴即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。
  - 如果客户端直接进⼊CLOSED状态，如果服务端没有接收到最后⼀次ACK包会在超时之后重新再发 FIN 包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK⽽是收到RST。所 TIME_WAIT 状态⽬的是防⽌最后⼀次握⼿数据没有到达对⽅⽽触发重传FIN准备的。
  - 在 2MSL 时间内，同⼀个socket不能再被使⽤，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。

### 8. 为什么握⼿是三次，挥⼿是四次

- 对于握⼿：握⼿只需要确认双⽅通信时的初始化序号，保证通信不会乱序。（**第三次握⼿**必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同⼀个客户机保持多个连接，造成资源浪费。）
- 对于挥⼿：TCP 是**全双⼯通信**的，所以发送⽅和接收⽅都需要 FIN 和 ACK。只不过有⼀⽅是被动的，所以看上去就成了4次挥⼿。

### 9. 什么是超时重传、RTT 和 RTO

- **超时重传：**发送端发送报⽂后若**⻓时间未收到确认**的报⽂则需要重发该报⽂。可能有以下⼏种情况：
  - 发送的数据没能到达接收端，所以对⽅没有响应
  - 接收端接收到数据，但是ACK报⽂在返回过程中丢失
  - 接收端拒绝或丢弃数据
- **报文段的往返时间 RTT：** 数据从发送到接收到对⽅响应之间的时间间隔，即数据报在⽹络中**⼀个往返⽤时**，其⼤⼩不稳定。
- **超时重传时间 RTO：**从上⼀次发送数据，因为⻓期没有收到 ACK 响应，到下⼀次重发之间的时间，就是**重传间隔**。
  - 通常每次重传RTO是前⼀次重传间隔的两倍，计量单位通常是 RTT，例：1RTT，2RTT，4RTT，
    8RTT......
  - 重传次数到达上限之后停⽌重传

### 10. TCP 滑动窗口

- TCP是双⼯协议，双⽅可以同时通信，所以发送⽅接收⽅各⾃维护⼀个**发送窗和接收窗**。
  - 发送窗：⽤来限制发送⽅可以发送的数据⼤⼩，其中发送窗⼝的⼤⼩由接收端返回的TCP报⽂段中窗⼝字段来控制，接收⽅通过此字段告知发送⽅⾃⼰的缓冲（受系统、硬件等限制）⼤⼩。
  - 接收窗：⽤来标记可以接收的数据⼤⼩。
- TCP 是流数据
  - 发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | **已发送未被确认部分 | 未发送但可发送部分** | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。
  - 接收到的数据流可分为：已接收 | **未接收但准备接收** | 未接收不准备接收。接收窗 = 未接收但准备接收部分。
- 发送窗内数据只有当接收到接收端某段发送数据的 ACK 响应时才移动发送窗，**左边缘**紧贴刚被确认的数据。接收窗也只有接收到数据且**最左侧**连续时才移动接收窗⼝。

**TCP 基于滑动窗口的重发机制**

- 滑动窗⼝机制，确⽴收发的边界，能让发送⽅知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收⽅知道（已经确认收到的字节数）。
- 选择重传，⽤于对传输出错的序列进行重传。

### 11. 什么是流量控制

​	流量控制⽬的是接收⽅通过 TCP 头窗⼝字段告知发送⽅本⽅可接收的最⼤数据量，⽤以**解决发送速率过快导致接收⽅不能接收的问题**，所以流量控制是**点对点控制**。

### 12. 什么是拥塞控制

​	拥塞控制⽬的是防⽌数据被过多注⽹络中导致⽹络资源（路由器、交换机等）过载。因为拥塞控制涉及⽹络链路全局，所以属于**全局控制**，控制拥塞使⽤拥塞窗⼝。

### 13. TCP 的拥塞控制算法

TCP 主要通过四个算法来进行拥塞控制：

**慢开始**：cwnd  = 1, 每个轮次 cwnd 加倍增长

**拥塞避免**：cwnd >= ssthresh, cwnd 线性增长，每个轮次只将 cwnd 加 1

**快重传**：三个重复确认立即重传丢失的报文段

**快恢复**：ssthresh = cwnd / 2, cwnd = ssthresh

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

![TCP拥塞控制](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP拥塞控制.jpg)

**慢开始与拥塞避免**

发送的最初执行**慢开始，令 cwnd = 1**，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到**慢开始每个轮次都将 cwnd 加倍**，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。

设置一个**慢开始门限 ssthresh**，当 cwnd >= ssthresh 时，进入**拥塞避免，每个轮次只将 cwnd 加 1**。

如果出现了**超时**，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到**三个重复确认**，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而**快恢复 cwnd 设定为 ssthresh**。

<img src="/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/Network-IMG/TCP快重传.jpg" alt="TCP快重传" style="zoom:67%;" />

**超时与3ACK**

- 超时：判断为出现网络拥塞，令 **ssthresh = cwnd / 2**，然后重新执行慢开始 **cwnd = 1**
- 3ACK：三个重复确认避免判断为超时情况，发送方也就不会误认为出现了网络拥塞，这时执行快重传立即重传丢失的报文段，接着执行快恢复令 **ssthresh = cwnd / 2 ，cwnd = ssthresh**，避免直接判断为拥塞情况重新执行慢开始降低传输效率。

**慢开始门限用法**

- cwnd < ssthresh : 执行慢开始
- cwnd > ssthresh : 停止慢开始 指向拥塞避免
- cwnd = ssthresh : 可以使用慢开始，也可以使用拥塞避免

### 14. TCP 如何实现提供可靠数据传输

- 建⽴连接（标志位）：通信前确认通信实体存在。
- 序号机制（序号、确认号）：确保了数据是按序、完整到达。
- 数据校验（校验和）：CRC 校验全部数据。
- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。
- 窗⼝机制（窗⼝）：提供流量控制，避免过量发送。
- 拥塞控制：提供拥塞控制，避免网络拥塞。

## 应用层

### 1. 统一资源定位符 URL 是什么

​	URL 是用来个表示从互联网上得到的资源位置和访问这些资源的方法，**URL 给资源的位置提供了一种抽象的识别方法**。

​	URL 一般形式由四个部分组成： `<协议>://<主机>:<端口>/<路径>`，携带参数的情况 `<协议>://<主机>:<端口>/<路径>?<参数>`

### 2. 浏览器中输入网址之后到显示页面的过程

1. 输入 URL，如果浏览器有缓存且未过期，则直接使用缓存渲染页面
2. 浏览器解析 URL，获取主机域名等信息
3. DNS 解析，根据主机域名获取主机 IP 地址
4. 根据 IP 地址建立 TCP 连接
5. 建立连接之后，向服务端发送 HTTP 请求
6. 服务端处理 HTTP 请求，处理之后将请求的资源作为响应体，通过 HTTP 响应返回给浏览器
7. 浏览器对 HTTP 响应内容进行解析，根据状态码进行对应处理，根据响应头字段判断是否启用缓存（cache-control 可缓存，no-store 不可缓存）
8. 并将请求到的资源渲染出页面
9. 连接结束

### 3. 常用的 HTTP 方法

 **GET**：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
 **POST**：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
 **PUT**： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
 **HEAD**： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
 **DELETE**：删除文件，与PUT方法相反，删除对应URI位置的文件。
 **OPTIONS**：查询相应URI支持的HTTP方法。

### 4. GET 方法和 POST 方法的区别

- 使用场景：GET 用于从指定的资源**请求**数据，⽽ POST ⽤于向指定的资源**提交**要被处理的数据。
- 传递参数：
  - GET 方法的参数是以查询字符串的形式放在 URL 后，而 POST 则是将参数存储在请求实体中。
  - 另外 URL 仅支持 ASCII 码所以如果参数中出现中文等其他字符需要进行编码，否在会出现乱码情况；而 POST 支持标准字符集，可以正确的传递中文等字符。
  - GET 传递的参数放在 URL 中是完全暴露的，存在数据安全的问题；而 POST 方法的参数则存在在请求实体中。
- 安全性：GET 方法是安全的因为它仅请求资源，不会改变服务器状态；POST 方法则需要提交请求实体，其中的内容可能会改变服务端数据内容，从而改变了服务器状态态，所以是不安全的。
- 缓存：GET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以**可以使用缓存**。POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以**不能使用缓存**。
- 幂等性

### 5. HTTP 请求报文和响应报文的格式

**请求报文**：请求行+请求头部+空行+请求主体

```
POST /user HTTP/1.1                       // 请求行
User-Agent：产生请求的浏览器类型(火狐还是谷歌浏览器)
Host：请求的主机名，即请求的网址
connection：连接方式(close 或 keepalive)
Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie
Content-Type：代表发送端（客户端|服务器）发送的实体数据的数据类型  
Accept：代表发送端（客户端）希望接受的数据类型   // 以上是请求头
（此处必须有一空行 |                         // 空行分割header和请求内容 
name=world                                // 请求体(可选，如get请求时可选)
```

**响应报文**：状态行+响应头部+空行+响应主体

```
HTTP/1.1 200 OK                           // 状态行
Date标头：响应产生的时间
Age标头:（从最初创建开始）响应持续时间
Server标头: 向客户端标明服务器程序名称和版本
Content-Length标头：响应实体的长度
Content-Tyep标头：响应实体的类型             // 以上是请响应头
（此处必须有一空行 |                         // 空行分割header和请求内容 
name=world                                // 响应体
```

### 6. HTTP 常用的状态码

**状态码分类**

1xx：表示⽬前是协议的中间状态，**正在处理**还需要后续请求

2xx：表示**请求成功**

3xx：表示**重定向**状态，需要重新请求

4xx：表示**请求报⽂错误**

5xx：表示**服务端错误**

**常⽤状态码**

101 切换请求协议，从 HTTP 切换到 WebSocket

200 请求成功，有响应体

301 **永久**重定向：会缓存

302 **临时**重定向：不会缓存

304 协商缓存命中

403 服务器**禁⽌访问**

404 资源**未找到**

400 **请求错误**

500 服务端错误

503 服务器**繁忙**

### 7. HTTP 301 和 302 状态码的区别

重定向：多个域名跳转至同一域名

301 重定向是页⾯**永久性转移**，搜索引擎在抓取新内容的同时也将旧的⽹址替换成重定向之后的网址

302 重定向是⻚⾯**暂时性转移**，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。

### 8. HTTP 500 状态码的具体场景

- 运行的**用户数过多**，对服务器造成的压力过大，服务器无法响应
- 操作涉及数据库，大数据量的情况下导致数据库中表空间已满，或者数据库连接池较小无法满足数据的存取等

### 9. HTTP 的优化方案

1. TCP 复用：一个客户端的多个HTTP请求通过一个TCP连接进行处理（HTTP 1.1 长连接）
2. 压缩：将文本数据进行压缩，减少带宽（HTTP 2.0 压缩优化）
3. 内容缓存：将经常用到的内容进行缓存起来，客户端可以直接在内存中获取相应的数据（Session 和 Cookie）
4. 安全性：SSL 加速（SSL Acceleration），使用 SSL 协议对 HTTP 协议进行加密，在通道内加密并加速（HTTPS）

### 10. HTTP 1.0, 1.1, 2.0 的区别

​	**HTTP 1.0**：浏览器与服务器只保持短暂的连接，连接**⽆法复用**。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。这种⽅式就好像打电话的时候，只能说⼀件事，说完之后就要挂断；想要说另外⼀件事的时候就要重新拨打电话。

​	**HTTP 1.1**：相对于 1.0 最主要的改进就是引⼊了**持久连接**。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用，提升了 HTTP 的效率。

​	**HTTP 2.0**： 2.0 采⽤了**多路复用**。即在⼀个连接里，客户端和浏览器都可以同时发送多个请求或回应，⽽且不⽤按照顺序⼀一对应。能实现多路复用的基础是**二进制分帧**，将请求进一步**拆分**并进行二进制编码，最终响应结果由多个子响应**组装**而成。除此之外，2.0 还进行了压缩优化，将文本数据进行压缩，减少带宽。

### 11. Cookie 和 Session 的区别

​	由于 HTTP 协议是**⽆状态协议**，所以服务端需要记录⽤户的状态时，就需要用某种机制来识具体的⽤户，这种机制就是服务端为特定的用户创建特定的 Session 用于标识和跟踪特定用户。

​	Session 是在**服务端保存**的⼀个数据结构，用来跟踪⽤户的状态，这个数据可以保存在集群、数据库和⽂件中。Cookie 是**客户端保存**用户信息的一种机制，⽤来记录用户的⼀些信息，也是实现 Session 的一种⽅式。

​	Cookie 要参与服务端通信，客户端每次向服务端发送 HTTP 请求是 cookie 记录的用户信息都被存储于**请求头部**中；所以 Cookie 的存储的数据大小不能超过 4K，否则将会带来性能问题。而 Session 不参与服务端通信，有着更大的数据存储大小，一般不超过 5M。

​	Session 和 Cookie 的有效期也不同，Session 在当前会话下有效，关闭页面或者浏览器时会被清空；Cookie 在设置的有效期内有效，当超过有效期便会自动失效。

### 12. HTTP 与 HTTPS 的区别

​	HTTP 的中文叫做超文本传输协议,它负责完成客户端到服务端的一系列操作，是专门用来传输注入 HTML的超媒体文档等 web 内容的协议，它是**基于传输层的 TCP** 协议的应用层协议。

​	HTTPS ( Hyper Text Transfer Protocol over SecureSocket Layer ) 是基于安全套接字的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性，也可以理解为是 HTTP + SSL / TLS (数字证书) 的组合。

http和https的区别:

- URL 标识：HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
- 开销：HTTP 无需认证证书，而 HTTPS 需要认证证书
- 安全性：HTTP 连接较为简单，是无状态的；而 HTTPS 通过传输加密和身份认证保证了传输过程的安全性
- 端口：HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
- 资源消耗：HTTP 是明文传输，HTTPS 使用了 SSL 加密传输协议，需要消耗更多的系统资源

**小结**：简单来说 http 是用来进行 html 等超媒体传输的，但是http不安全，为了安全使用证书 SSL 和HTTP 的方式进行数据传输，也就是 HTTPS。
