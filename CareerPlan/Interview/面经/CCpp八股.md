## 01 语言理解

### 1. C 和 C++ 的区别



### 2. 面向对象和面向过程编程的区别



### 3. C++ 和 Java 的区别



### 4. C++ 和 Python 的区别





## 02 内存管理

### 1. C++ 中内存分配情况

栈区：由**编译器自动**管理分配和回收，存放**局部变量和函数参数**。

堆区：由**程序员手动**管理，需要手动通过代码 new malloc delete free 完成内存空间的分配和回收，空间较⼤，一般比较**复杂的数据类型**都是放在堆中，但可能会出现内存泄漏和空闲碎⽚的情况。

静态区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的**全局变量和静态变量**。（全局变量：出现在代码块{}之外的变量就是全局变量；静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。）

代码区：存放程序的**⼆进制代码**，这块内存在程序运行期间是不变的。

### 2. 堆和栈区别

**栈**

- 由**编译器自动管理**，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

- **连续的内存空间**，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，**不会产⽣碎⽚**。

- 栈是⾼地址向低地址扩展，栈低⾼地址，**空间较⼩**。

**堆**

- 由**程序员管理**，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

- **不连续的空间**，实际上系统中有⼀个空闲**链表**，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。

- 堆是低地址向⾼地址扩展，**空间交⼤**，较为灵活。

### 3. malloc / free 和 new / delete 的区别

**相同点：**

​	都可以⽤来在堆上分配和回收空间。

**不同点：**

- `malloc/free` 是 C/C++ 语言的标准**库函数**；`new/delete` 是 C++ 中的**运算符**。
- `malloc` 返回类型是 `void*`，使用时需要类型转换；而 `new` 的返回类型是指向**对象类型的指针**。
- `malloc/free`  只分配和回收**指定大小**的堆内存空间，而 `new/delete` 可以**根据对象类型**分配和回收合适的堆内存空间。
- 使用 `new/delete` 将调用构造函数或析构函数初始化或析构对象，而 `malloc/free` 没有该操作。

**new/delete 的执行过程：**

- 执⾏ new 实际上执⾏两个过程：
  - 分配未初始化的内存空间（malloc）。如果分配空间出现问题，则抛出 `std::bad_alloc` 异常，或被某个设定的异常处理函数捕获处理。
  - 使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在构造对象时出现异常，则⾃动调⽤ delete 释放内存。
- 执⾏ delete 实际上也有两个过程：
  - 使⽤析构函数对对象进⾏析构；
  - 回收内存空间（free）。

**为什么有了 malloc / free 还需要 new / delete？**

​	因为对于⾮内部数据类型（复杂数据结构）⽽⾔，光⽤ `malloc/free` ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。

​	由于 `mallo / free` 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务直接强加于 `malloc/free`，所以有了 `new / delete` 运算符对其进行进一步的扩展。

### 4. 什么是内存泄漏和内存溢出

**内存泄漏：**

​	内存泄漏简单的说就是申请了⼀块内存空间，**使⽤完毕后没有释放掉**，占用了有用内存。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

**内存溢出：**

​	内存溢出是指程序在申请内存时，**没有足够的内存空间供其使用**。内存泄漏的堆积最终会导致内存溢出内存溢出，就是程序申请的内存空间超过了系统实际可分配的空间，此时系统无法满足程序的需求，就会报内存溢出的错误。

**如何检测内存泄漏：**

- ⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
- 还可以使⽤其他⼀些 `/usr/bin/stat` ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
- 当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。

### 5. 结构体内存对齐方式与作用

​	结构体作为⼀种复合数据类型，其构成元素既可以是基本数据类型的变量，也可以是一些复合型数据。对此，编译器会⾃动进行成员变量的对齐以提高运算效率。默认情况下，按自然对齐条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同，向结构体成员中size最大的成员对齐。

​	经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。

## 03 指针与引用





## 04 基础语法

### 1. const 关键字的作用

- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
- 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改，相当于常指针常量；
- 修饰成员函数，说明该成员函数内不能修改成员变量。
- 修饰对象，常量对象只能调用常量函数。

### 2. 宏定义 #define 和 const 的区别

|      区别      |                #define                 |              const               |
| :------------: | :------------------------------------: | :------------------------------: |
| 编译器处理方式 |              预处理器处理              |            编译器处理            |
|  类型安全检查  |             无类型安全检查             |          有类型安全检查          |
|    存储方式    | 存储在代码段、代码字符替换、不分配内存 | 存储在数据段、常量声明、分配内存 |
|     定义域     |             不受定义域限制             |         只在定义域内有效         |

- 编译器处理方式不同： #define 宏是在预处理阶段展开，不能对宏定义进⾏调试；而 const 常量量是在编译阶段使⽤；
- 类型和安全检查不同： #define 宏没有类型，不不做任何类型检查，仅仅是代码展开，可能产⽣生边际效应等错误；⽽ const 常量有具体类型，在编译阶段会执⾏类型检查；
- 存储⽅式不同： #define 宏仅仅是代码展开，在多个地方进⾏字符串替换，不会分配内存，存储于程序的代码段中；⽽ const 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
- 定义域不不同： #define 宏不受定义域限制，而 const 常量只在定义域内有效。

### 3. 宏定义 #define 和 typedef 的区别



### 4. static 关键字的作用

- 修饰局部变量：修改局部变量的**存储区域和生命周期**，使其存储在静态区；只能在⾸次函数调⽤中进⾏⾸次初始化，之后的函数调用不再进⾏初始化；其⽣命周期与程序相同，但其作用域为局部作⽤域，并不能⼀直被访问。
- 修饰全局变量：修改全局变量的**作用域范围**，使变量仅能在文件内可访问，不加修饰可以在整个工程中被访问。该变量在整个**文件内**都可被访问，但是对之外的文件不可见。
- 修饰普通函数：表明函数的作用范围，仅在定义该函数的**文件内**才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
- 修饰成员变量：修饰成员变量使所有的对象只维持**一份拷贝**，实现不同对象之间的**数据共享**；而且不需要生成对象就可以访问该成员，一般在类外部完成初始化。
- 修饰成员函数：修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数**只能访问静态成员**。

### 5. 为什么 static 成员要在类外部完成初始化

​	因为被static声明的类静态成员变量，其实体远在 `main()` 函数开始之前就已经在全局数据段中存在了，其生命期和类对象是异步的。

​	这时类对象的生命期还没有开始，如果要在类内初始化类静态成员变量，那么其初始化操作就需要依赖于类的实例化，这样就无法实现**不生成对象就可以访问该成员变量的静态语意**了。 静态语意说明即使没有类实体的存在，其静态成员变量的实体也是存在并且可访问的。

## 05 面向对象

### 1. 面向对象的三大特性

- 封装：将客观事物封装成抽象的类，⽽类可以把⾃⼰的数据和⽅法暴露给可信的类或者对象，对不不可信的类或对象则进行信息隐藏。更抽象的说：**封装就是将完成一个功能所需要的所有东西都放在一起，对外部只提供调用的接口**。
- 继承：可以使用现有类的所有功能，并且⽆需重新编写原来的类即可对功能进⾏拓展；**即子类继承父类的特性，并在此基础上进行扩展**。
- 多态：⼀个类实例的相同⽅法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接⼝。即**一个函数，多种实现**，多态性的表现在于程序运行时根据调用对象的不同，调用不同的函数。多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。

### 2. 怎么实现多态

多态分为静态多态和动态多态，其中：

- 静态多态是通过**重载**和**模板**技术实现的，在**编译期间确定**；
- 动态多态是通过**虚函数和继承关系**实现的，执行动态绑定，在**运⾏期间确定**。

### 3. 什么是虚函数，它是怎么实现的

​	在类的定义中，有 `virtual` 关键字的成员函数就是虚函数。

​	虚函数的实现：在有虚函数的类中，类的最开始部分是⼀个虚函数表的指针，这个指针指向⼀个虚函数表，表中放了虚函数的地址。当⼦类继承了⽗类的时候也会继承其虚函数表，当⼦类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。因为虚函数表和查询的存在，使⽤虚函数，会增加访问内存开销，降低效率。

### 4. 动态多态的作用

​	在面向对象的程序设计中使用多态能够**增强程序的可扩充性和代码可复用性**，即程序需要修改或增加功能的时候，避免大量代码的改动和增加。

​	但是多态的机制会增加程序执行时在时间和空间上的开销，空间上是由于存在虚函数的类的每个对象在创建时都会多出 4 个字节的额外空间开销用于**存放虚函数表的地址**；时间上是由于在**查虚函数表**的过程中需要消耗一定的时间。

### 5. 动态多态的实现原理

​	多态的关键在于通过**基类指针**或**基类引用**调用虚函数时，编译时还不确定该语句调用的是基类函数还是派生类函数，直到运行时才能确定，这种机制也称为**动态联编**。

​	具体过程：当编译器发现类中有虚函数时，会创建⼀张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加⼀个指针 `vptr` ，用于指向类的虚函数表。当派⽣类覆盖基类的虚函数时，会将虚函数表中对应的指针进⾏替换，从⽽调⽤派生类中覆盖后的虚函数，实现动态联编。

### 6. 什么是纯虚函数，它有什么作用

​	**纯虚函数**是没有函数体的虚函数，`virtual void Print() = 0;`

​	定义纯虚函数是为了实现接口，这种接口又称为**抽象类**，即包含纯虚函数的类。抽象类是起到规范的作用，想要继承这个类就必须实现所有纯虚函数，否则派生类仍为抽象类。

### 7. 基类构造函数为什么不能是虚函数

​	虚函数的调⽤依赖于虚函数表，⽽指向虚函数表的指针 vptr 需要在构造函数中进⾏初始化，所以无法调⽤定义为虚函数的构造函数。

### 8. 为什么不能在构造函数中调用虚函数

​	因为派生类调用构造函数期间会先调用基类构造函数，如果基类构造函数中存在多态并调用了派生类的虚函数，这时派生类还未调用构造函数完成初始化，这将导致错误的运行结果。

### 9. 析构函数为什么一般写成虚函数

​	当通过基类指针销毁派生类对象时，通常只有基类的析构函数被调用，只能销毁派⽣类对象中的部分数据，这就出现了析构不完整的情况。为此，可以将基类的析构函数声明为虚函数，派生类的析构函数就不需要进行虚函数声明，自动成为虚函数；这时，通过基类指针析构派生类对象时调用的就是派生类的析构函数，派生类的析构函数中会调用基类的析构函数，从⽽销毁派生类对象中的所有数据。

​	一般来说，一个类定义了虚函数，则应该将该类的析构函数声明为虚函数；另外，如果一个类要被作为基类使用，则也应该将该类的析构函数声明为虚函数。

### 10. 深拷贝和浅拷贝的区别

​	浅拷⻉只复制指向某个对象的**指针**，⽽不复制对象本身，新旧对象还是**共享⼀块内存**；而深拷贝会**创造**⼀个相同的对象，新对象与原对象**不共享内存**，修改新对象不会影响原对象。

​	当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。

​	但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指野指针的问题。这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从⽽也就解决来野指针的问题。

​	简⽽⾔之，当**数据成员中有指针**时，必需要⽤深拷⻉更加安全。

### 11. 重载、重写与重定义

- **重载**：是指同一可访问区内被声明的几个具有**不同参数列表**（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
- **重写(覆盖)**：是指派生类中存在重新定义的函数。**其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有**函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须为虚函数。
- **重定义(隐藏)**：是指派生类的函数屏蔽了与其**同名非虚函数**的基类函数；注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

## 06 C++ STL



### vector 有了 push_back() 还要 emplace_back



## 07 C++ 11 新特性

