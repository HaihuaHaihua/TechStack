## 01 语言理解

### 1. C 和 C++ 的区别

- 编程范式：C++ 是⾯向对象的语⾔言，⽽ C 是⾯向过程的语言；
- 语法：C++ 引入 new/delete 运算符，取代了C中的 malloc/free 库函数；C++引⼊引⽤的概念，⽽而C中没有；新增了 bool 数据类型
- 函数：C++引⼊函数重载和模板，⽽ C 中没有
- 类：C++引⼊类的概念，并增加了虚函数的概念，由于实现多态

### 2. 面向对象和面向过程编程的区别

**面向过程编程的概念**：是进行以模块功能和处理过程设计为主的详细设计的基本原则

**结构化程序设计的不足**：随着程序规模的扩大，难以**理解**、难以**扩充**、难以**查错**、难以**重用**。

**面向对象编程的概念**：客观事物的**抽象**过程，归纳客观事物的**属性**，归纳客观事物的**行为**

**面向对象程序设计的四个特点**：抽象、封装、继承、多态。**封装**：通过某种语法形式，将客观事物抽象的数据结构和对应操作的函数捆绑在一起，形成一个**类 (class)**，从而使得数据结构和操作函数呈现出清晰的关系，这称为**封装**。

### 3. C++ 和 Java 的区别

- 指针：Java 语⾔让程序员没法找到指针来直接访问内存，**没有指针的概念**，并有内存的⾃动管理功能，从⽽有效的防⽌了 C++ 语⾔中的指针操作失误的影响。
- 垃圾回收：自动内存管理，Java ⾃动进⾏⽆⽤内存回收操作，不需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源 delete/delete[]
- 类：Java 中取消了 C++ 中的 struct 和 union

### 4. C++ 和 Python 的区别

- 执行方式不同：c++ 是编译型语言需要经过编译才能运行；Python是解释型的脚本语言，不需要经过编译。
- 语言类型不同：c++属于静态类型；Python属于动态类型，但都是强类型语言不能进行隐式转换。

- 运行效率不同：c++的运行效率要比Python快。

## 02 内存管理

### 1. C++ 中内存分配情况

栈区：由**编译器自动**管理分配和回收，存放**局部变量和函数参数**。

堆区：由**程序员手动**管理，需要手动通过代码 new malloc delete free 完成内存空间的分配和回收，空间较⼤，一般比较**复杂的数据类型**都是放在堆中，但可能会出现内存泄漏和空闲碎⽚的情况。

静态区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的**全局变量和静态变量**。（全局变量：出现在代码块{}之外的变量就是全局变量；静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。）

代码区：存放程序的**⼆进制代码**，这块内存在程序运行期间是不变的。

### 2. 堆和栈区别

**栈**

- 由**编译器自动管理**，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

- **连续的内存空间**，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，**不会产⽣碎⽚**。

- 栈是⾼地址向低地址扩展，栈低⾼地址，**空间较⼩**。

**堆**

- 由**程序员管理**，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

- **不连续的空间**，实际上系统中有⼀个空闲**链表**，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。

- 堆是低地址向⾼地址扩展，**空间交⼤**，较为灵活。

### 3. malloc / free 和 new / delete 的区别

**相同点：**

​	都可以⽤来在堆上分配和回收空间。

**不同点：**

- `malloc/free` 是 C/C++ 语言的标准**库函数**；`new/delete` 是 C++ 中的**运算符**。
- `malloc` 返回类型是 `void*`，使用时需要类型转换；而 `new` 的返回类型是指向**对象类型的指针**。
- `malloc/free`  只分配和回收**指定大小**的堆内存空间，而 `new/delete` 可以**根据对象类型**分配和回收合适的堆内存空间。
- 使用 `new/delete` 将调用构造函数或析构函数初始化或析构对象，而 `malloc/free` 没有该操作。

**new/delete 的执行过程：**

- 执⾏ new 实际上执⾏两个过程：
  - 分配未初始化的内存空间（malloc）。如果分配空间出现问题，则抛出 `std::bad_alloc` 异常，或被某个设定的异常处理函数捕获处理。
  - 使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在构造对象时出现异常，则⾃动调⽤ delete 释放内存。
- 执⾏ delete 实际上也有两个过程：
  - 使⽤析构函数对对象进⾏析构；
  - 回收内存空间（free）。

**为什么有了 malloc / free 还需要 new / delete？**

​	因为对于⾮内部数据类型（复杂数据结构）⽽⾔，光⽤ `malloc/free` ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。

​	由于 `mallo / free` 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务直接强加于 `malloc/free`，所以有了 `new / delete` 运算符对其进行进一步的扩展。

### 4. 什么是内存泄漏和内存溢出

**内存泄漏：**

​	内存泄漏简单的说就是申请了⼀块内存空间，**使⽤完毕后没有释放掉**，占用了有用内存。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

**内存溢出：**

​	内存溢出是指程序在申请内存时，**没有足够的内存空间供其使用**。内存泄漏的堆积最终会导致内存溢出内存溢出，就是程序申请的内存空间超过了系统实际可分配的空间，此时系统无法满足程序的需求，就会报内存溢出的错误。

**如何检测内存泄漏：**

- ⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。
- 还可以使⽤其他⼀些 `/usr/bin/stat` ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。
- 当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。

### 5. 结构体内存对齐方式与作用

​	结构体作为⼀种复合数据类型，其构成元素既可以是基本数据类型的变量，也可以是一些复合型数据。对此，编译器会⾃动进行成员变量的对齐以提高运算效率。默认情况下，按自然对齐条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同，向结构体成员中size最大的成员对齐。

​	经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。

### 6. 什么是栈溢出

- **局部数组过大：**当函数内部的数组过大时，有可能导致堆栈溢出。
- **递归调用层次太多：**递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。
- **指针或数组越界：**这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。当拷贝的字符串大大的超过变量空间就会破坏堆栈

解决这类问题的办法有两个

- 增大栈空间
- 改用动态分配，使用堆（heap）而不是栈（stack）

### 7. 什么是堆破坏

​	堆破坏是指没控制好自己的指针，把不属于你分配的那块内存给写覆盖。

​	一般来说，堆破坏往往都是**写数据越界造成的**，所以微软在堆分配上，给程序员门额外提供了2种堆分配模式--完全页堆（full page heap），准页堆(normal page heap)，用来检测堆被写越界的情况。

## 03 指针与引用

### 1. 指针和引用的区别

**引用的概念**：某个变量的引用，等价于这个变量，相当于该变量的一个**别名**；**本质上来说引用是指针常量，可以修改指向的值，但是不能修改地址**。

**指针和引用的区别**：

- 在声明引用时一定要对其**初始化**；而指针**不需要初始化**
- 引用经初始化后，就不可以再和其他对象绑定在一起了，一直引用该对象（从一而终），**不能被改变**；指针**可以改变**其所指向的对象。
- 引用只能引用变量，不能引用常量和表达式，且**不存在指向空值**的引用；但是指针**可以指向空值**。

## 04 基础语法

### 1. const 关键字的作用

- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
- 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改，相当于常指针常量；
- 修饰成员函数，说明该成员函数内不能修改成员变量。
- 修饰对象，常量对象只能调用常量函数。

### 2. 宏定义 #define 和 const 的区别

|      区别      |                #define                 |              const               |
| :------------: | :------------------------------------: | :------------------------------: |
| 编译器处理方式 |              预处理器处理              |            编译器处理            |
|  类型安全检查  |             无类型安全检查             |          有类型安全检查          |
|    存储方式    | 存储在代码段、代码字符替换、不分配内存 | 存储在数据段、常量声明、分配内存 |
|     定义域     |             不受定义域限制             |         只在定义域内有效         |

- 编译器处理方式不同： #define 宏是在预处理阶段展开，不能对宏定义进⾏调试；而 const 常量量是在编译阶段使⽤；
- 类型和安全检查不同： #define 宏没有类型，不不做任何类型检查，仅仅是代码展开，可能产⽣生边际效应等错误；⽽ const 常量有具体类型，在编译阶段会执⾏类型检查；
- 存储⽅式不同： #define 宏仅仅是代码展开，在多个地方进⾏字符串替换，不会分配内存，存储于程序的代码段中；⽽ const 常量会分配内存，但只维持一份拷贝，存储于程序的数据段中。
- 定义域不不同： #define 宏不受定义域限制，而 const 常量只在定义域内有效。

### 3. 宏定义 #define 和 typedef 的区别



### 4. static 关键字的作用

- 修饰局部变量：修改局部变量的**存储区域和生命周期**，使其存储在静态区；只能在⾸次函数调⽤中进⾏⾸次初始化，之后的函数调用不再进⾏初始化；其⽣命周期与程序相同，但其作用域为局部作⽤域，并不能⼀直被访问。
- 修饰全局变量：修改全局变量的**作用域范围**，使变量仅能在文件内可访问，不加修饰可以在整个工程中被访问。该变量在整个**文件内**都可被访问，但是对之外的文件不可见。
- 修饰普通函数：表明函数的作用范围，仅在定义该函数的**文件内**才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
- 修饰成员变量：修饰成员变量使所有的对象只维持**一份拷贝**，实现不同对象之间的**数据共享**；而且不需要生成对象就可以访问该成员，一般在类外部完成初始化。
- 修饰成员函数：修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数**只能访问静态成员**。

### 5. 为什么 static 成员要在类外部完成初始化

​	因为被static声明的类静态成员变量，其实体远在 `main()` 函数开始之前就已经在全局数据段中存在了，其生命期和类对象是异步的。

​	这时类对象的生命期还没有开始，如果要在类内初始化类静态成员变量，那么其初始化操作就需要依赖于类的实例化，这样就无法实现**不生成对象就可以访问该成员变量的静态语意**了。 静态语意说明即使没有类实体的存在，其静态成员变量的实体也是存在并且可访问的。

## 05 面向对象

### 1. 面向对象的三大特性

- 封装：将客观事物封装成抽象的类，⽽类可以把⾃⼰的数据和⽅法暴露给可信的类或者对象，对不不可信的类或对象则进行信息隐藏。更抽象的说：**封装就是将完成一个功能所需要的所有东西都放在一起，对外部只提供调用的接口**。
- 继承：可以使用现有类的所有功能，并且⽆需重新编写原来的类即可对功能进⾏拓展；**即子类继承父类的特性，并在此基础上进行扩展**。
- 多态：⼀个类实例的相同⽅法在不同情形下有不同的表现形式，使不同内部结构的对象可以共享相同的外部接⼝。即**一个函数，多种实现**，多态性的表现在于程序运行时根据调用对象的不同，调用不同的函数。多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。

### 2. 怎么实现多态

多态分为静态多态和动态多态，其中：

- 静态多态是通过**重载**和**模板**技术实现的，在**编译期间确定**；
- 动态多态是通过**虚函数和继承关系**实现的，执行动态绑定，在**运⾏期间确定**。

### 3. 什么是虚函数，它是怎么实现的

​	在类的定义中，有 `virtual` 关键字的成员函数就是虚函数。

​	虚函数的实现：在有虚函数的类中，类的最开始部分是⼀个虚函数表的指针，这个指针指向⼀个虚函数表，表中放了虚函数的地址。当⼦类继承了⽗类的时候也会继承其虚函数表，当⼦类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。因为虚函数表和查询的存在，使⽤虚函数，会增加访问内存开销，降低效率。

### 4. 动态多态的作用

​	在面向对象的程序设计中使用多态能够**增强程序的可扩充性和代码可复用性**，即程序需要修改或增加功能的时候，避免大量代码的改动和增加。

​	但是多态的机制会增加程序执行时在时间和空间上的开销，空间上是由于存在虚函数的类的每个对象在创建时都会多出 4 个字节的额外空间开销用于**存放虚函数表的地址**；时间上是由于在**查虚函数表**的过程中需要消耗一定的时间。

### 5. 动态多态的实现原理

​	多态的关键在于通过**基类指针**或**基类引用**调用虚函数时，编译时还不确定该语句调用的是基类函数还是派生类函数，直到运行时才能确定，这种机制也称为**动态联编**。

​	具体过程：当编译器发现类中有虚函数时，会创建⼀张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在对象中增加⼀个指针 `vptr` ，用于指向类的虚函数表。当派⽣类覆盖基类的虚函数时，会将虚函数表中对应的指针进⾏替换，从⽽调⽤派生类中覆盖后的虚函数，实现动态联编。

### 6. struct 和 class 的区别

​	C++ 中保留了 C 语言的 struct 关键字，并且加以扩充。在 C 语言中，struct 只能包含成员变量，不能包含成员函数。而在 C++ 中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数，能实现继承和多态。

​	C++ 中的 struct 和 class 基本是通用的，唯有几个细节不同：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承
- class 关键字还可以代替 `typename` 用于模板参数声明，而 struct 不可以

### 7. 什么是纯虚函数，它有什么作用

​	**纯虚函数**是没有函数体的虚函数，`virtual void Print() = 0;`

​	定义纯虚函数是为了实现接口，这种接口又称为**抽象类**，即包含纯虚函数的类。抽象类是起到规范的作用，想要继承这个类就必须实现所有纯虚函数，否则派生类仍为抽象类。

### 8. 抽象类和接口的区别

​	抽象类和接口都不能被实例化，但是他们的用途不一样：

- 抽象类主要目的是实现**代码复用**，即不同类具有某些相同属性和行为时，可以将这些相同属性抽象出来构成一个抽象类，这些不同的类可以通过继承该类实现代码复用。
- 接口的主要作用是**约束类的行为**，即一种强制不同类具有相同行为的机制。
- 一个类只能继承一个抽象类，但是一个类可以实现多个接口

### 9. 基类构造函数为什么不能是虚函数

​	虚函数的调⽤依赖于虚函数表，⽽指向虚函数表的指针 vptr 需要在构造函数中进⾏初始化，所以无法调⽤定义为虚函数的构造函数。

### 10. 为什么不能在构造函数中调用虚函数

​	因为派生类调用构造函数期间会先调用基类构造函数，如果基类构造函数中存在多态并调用了派生类的虚函数，这时派生类还未调用构造函数完成初始化，这将导致错误的运行结果。

### 11. 析构函数为什么一般写成虚函数

​	当通过基类指针销毁派生类对象时，通常只有基类的析构函数被调用，只能销毁派⽣类对象中的部分数据，这就出现了析构不完整的情况。为此，可以将基类的析构函数声明为虚函数，派生类的析构函数就不需要进行虚函数声明，自动成为虚函数；这时，通过基类指针析构派生类对象时调用的就是派生类的析构函数，派生类的析构函数中会调用基类的析构函数，从⽽销毁派生类对象中的所有数据。

​	一般来说，一个类定义了虚函数，则应该将该类的析构函数声明为虚函数；另外，如果一个类要被作为基类使用，则也应该将该类的析构函数声明为虚函数。

### 12. 深拷贝和浅拷贝的区别

​	浅拷⻉只复制指向某个对象的**指针**，⽽不复制对象本身，新旧对象还是**共享⼀块内存**；而深拷贝会**创造**⼀个相同的对象，新对象与原对象**不共享内存**，修改新对象不会影响原对象。

​	当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。

​	**但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指野指针的问题。**这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从⽽也就解决来野指针的问题。

​	简⽽⾔之，当**数据成员中有指针**时，必需要⽤深拷⻉更加安全。

### 13. 重载、重写与重定义

- **重载**：是指同一可访问区内被声明的几个具有**不同参数列表**（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
- **重写(覆盖)**：是指派生类中存在重新定义的函数。**其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致**。只有**函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须为虚函数。
- **重定义(隐藏)**：是指派生类的函数屏蔽了与其**同名非虚函数**的基类函数；注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

## 06 C++ STL

### 1. vector 与 array 的区别

​	vector 和 array 的数据组织和操作方式相近，两者的区别在于对空间运用的灵活性。

​	array 是静态空间，一旦配置就不可变更，如果需要扩大空间就需要自行重新配置新的空间，然后将元素从旧址搬到新址，并把旧空间释放掉。

​	vector 是动态空间，随着元素的加入，他的内部机制会自行扩充空间以容纳新元素，不需要手动配置空间，增强了内存的合理使用和运用的灵活性。

### 2. vector 的底层原理

​	vector底层数据结构是一个**线性连续空间**，包含三个迭代器器，`start` 和 `finish` 之间是已经被使⽤用的空间范围，`end_of_storage` 是整块连续空间包括备⽤用空间的尾部。

​	运用 `star, finish, end_of_storage` 三个迭代器，vector 可以提供如下机能：

- 首尾标示：`begin(), end()`
- 已使用大小：`size()`
- 总容量：`capacity()`
- 判空：`empty()`
- 括号运算符重载：`operator[]()`
- 最前端和最后端元素值：`front(), back()`

![vector](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/C/vector.png)

### 3. vector 的扩容机制

​	vector 实现的关键在于其对大小的控制以及重新配置是的数据移动效率。当 vector 的空间满载时，需要新插入一个元素，如果这时仅仅扩充一个元素的空间，会大大增加系统开销。

​	因为扩容往往不是直接增加空间，而是要经过**配置新空间 >> 数据移动 >> 释放旧空间**的繁琐过程，往往需要很高的时间成本。所以，为了减少扩容次数，当新增元素是，超过了当前的容量，则会将 vector 的容量根据扩容因子（一般为1.5 或 2）进行扩容，预留更多的备用空间。

**为什么扩容因子一般为 1.5 或 2 ？**

​	如果扩容因子过大，将导致堆空间浪费

### 4. vector resize() 与 reserve() 的区别

**resize()**

​	resize() 函数的作用是改变 vector 元素个数，包括两个参数 `resize(n,m)`，其中 第二个参数可以省略，n 代表改变元素个数为 n ,m 代表初始化为 m 。

​	resize() 可以改变有效空间的大小。如果 n 比 vector 的 size 小，结果是 size 减小到 n ，然后**删除** n 之后的数据。

​	resize() 也可以改变总空间的大小。如果 n 比 vector 的 capacity 大，结果是先增加容量，然后再增加 size 并初始化， capacity 和 size 均会被改变

**reserve()**

​	reserve() 函数的作用是改变总空间的大小，只有一个参数 `reverse(n)`，n 代表改变扩容到容量 n 。

- 如果 n 的值比大于 vector 的 size，则 capacity 增容到 n ，size 不变。
- 如果 n 的值比小于 vector 的 size，则 capacity ，size 都不变。

当将 reserve()，resize() 用于扩容时，可以直接扩充到已经确定的⼤大小，可以减少多次开辟、释放空间的问题，从而能够提高效率，减少多次数据拷贝的问题。

### 5. vector 迭代器失效的情况

​	**空间重新配置导致失效：**vector 空间的动态增加，并不是在原空间之后增加连续的新空间，而是直接重新配置一块更大的新空间，然后将数据拷贝到新空减，并将旧空间释放。所以，当对 vector 的操作引起空间重新配置时，指向原 vector 的迭代器全部失效了。

​	**元素被删除导致失效：**当删除容器中⼀个元素后，该迭代器所指向的元素已经被删除，也将造成该迭代器失效。erase 方法会返回下⼀一个有效的迭代器，所以当我们要删除某个元素时，需要`it=vec.erase(it);`。

### 6. vector 有了 push_back() 还要 emplace_back

​	在引入右值引用，移动构造函数，移动复制运算符之前，通常使用push_back()向容器中加入一个右值元素(临时对象)的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。

​	引入右值引用，移动构造函数后，push_back()右值时就会调用构造函数和移动构造函数。

​	在这上面有进一步优化的空间就是使用emplace_back，在容器尾部添加一个元素，这个**元素原地构造，不需要触发拷贝构造和移动构造**。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。

```cpp
vector<_Tp, _Alloc>::emplace_back(_Args &&... __args) {
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage) {
        // 同样判断容器是否满了，没满的话，执行构造函数，对元素进行构造，并执行类型转换
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 std::forward<_Args>(__args)...);
        ++this->_M_impl._M_finish; // 更新当前容器大小
    } else
        // 满了的话重新申请内存空间，将新的元素继续构造进来，并且进行类型转换
        _M_realloc_insert(end(), std::forward<_Args>(__args)...);
#if __cplusplus > 201402L
    return back(); // 在 C++14版本之后，添加返回值，返回最后一个元素的引用
#endif
}
```

https://zhuanlan.zhihu.com/p/183861524

- 如果插入vector的类型的构造函数接受多个参数，那么push_back只能接受该类型的**对象**（实例），emplace_back 还能接受该类型的构造函数的参数（多个参数）。
- 如果**传入的是构造函数能接受的参数**，emplace_back() 不需要调用构造函数就可以直接进行原地构造，性能更好。如果传入的是对象实例，这两种方法没什么区别都要调用拷贝构造函数，如果是临时对象就都调用移动构造函数。

### 7. list 的底层原理

​	list 的底层是一个**双向链表**，以结点为单位存放数据，结点的地址在内存中不⼀定连续，每次插⼊或删除一个元素，就配置或释放一个元素空间。

​	list 不支持随机存取，适合需要⼤量的插入和删除，⽽不关⼼随即存取的应用场景。

![list](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/C/list.png)

### 8. deque 的底层原理

​	deque 的底层是**分段连续线性空间**，他是由一段一段的定量连续空间构成的，一旦有需要就在 deque 的头或尾部配置一段定量连续空间，串接在整个 deque 的头部或尾部。

​	deque 的最大任务就是维护这些分段连续空间是**整体连续的假象**，并提供了随机存取的接口。通过这种方式避免了 vector 扩容过程中的时间成本与资源消耗，而代价则是复杂的迭代器架构。

​	**数据结构上，deque 使用一小块被称为 map 的连续空间存储指向不同分段连续线性空间的指针，而这些被指向的连续线性空间被称为缓冲区，它们作为存储 deque 元素的主体。**

​	deque 是一个双向开口的连续线性空间（**双端队列**），在头尾两端进行元素的插⼊和删除操作都有较好的时间复杂度。

![deque](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/C/deque.png)

### 9. vector, list, deque 的使用场景

- vector 适用于随机访问频繁，元素对象简单且通过尾部插入的场景。
- deque 虽然功能上比 vector 强大，且支持随机访问，但是其迭代器十分复杂，尽量避免使用 deque。
- list 不支持随机存取，但是适用于对象大，对象数量变化频繁，插入和删除操作较多的使用场景。

### 10. set, map 的底层原理

​	set, map的底层实现都是红黑树，红黑树是一种平衡二叉搜索树，有较好的自动排序效果，能够实现`O(logN)`的时间复杂度内的搜索、插入和删除操作。

<img src="/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/C/map.png" alt="map" style="zoom:60%;" />

​	红黑树的性质：

- 所有节点都是红色或者黑色
- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NULL）
- 父子节点不能同时为红色
- 任意节点到达空节点（NULL）的路径上的黑色节点的数量必须相同

​    当对红黑树进行插入或删除操作导致上述性质被破坏时，红黑树就出现了不平衡状态，必须要调整节点颜色并旋转树形恢复平衡。

### 11. 红黑树和 AVL 树的区别

​	红黑树和 AVL 树都是二叉搜索树，二叉搜索树的查找、插入和删除操作的时间复杂度都是与其自身的高度相关的，平均情况下时间复杂度为`O(logN)`。但是二叉搜索树可能出现向右倾斜的情况，导致二叉搜索树退化为一个链表，这时二叉搜索树的查找、插入和删除操作的时间复杂度就变成了`O(N)`。

​	为了解决这一问题，提出了平衡二叉搜索树，AVL 是一种高度平衡的二叉搜索树，它的平衡条件是**所有非叶子节点的左右子树均为平衡二叉树，且左右子树的高度差的绝对值不超过 1**。这就实现了最坏情况下 AVL 树的查找、插入和删除操作的时间复杂度为`O(logN)`。

​	但是由于 AVL 树严格的平衡条件，使得每次插入或删除操作时都可能破坏平衡状态，一旦平衡被破坏就需要通过繁琐的树形旋转进行调整。所以，AVL 树不适用于频繁插入或删除操作的场景。

​	红黑树在这一问题上进行了优化，它的平衡条件没有 AVL 树那么严格，所以插入或删除操作并不容易被打破，即使平衡被破坏它也可以通过更加简易的颜色和树形调整完成平衡恢复。所以红黑树能够更好的应对频繁插入或删除操作的场景。

### 12. 红黑树的应用场景

- STL 中 set 和 map 底层实现都是红黑树
- epoll 模型的底层数据结构也是红黑树
- linux系统中 CFS **进程调度算法**，也⽤到红黑树

### 13. B 树和 AVL 树的区别

- B 树是多叉搜索树，AVL 树是二叉搜索树
- B 树一个节点中可以存储多个关键字，AVL 树一个节点通常只放一个关键字

### 14. B 树和 B+ 树的区别

- B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 `O(logN)`。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为`O(1)`。
- B+树内节点无 data 域，每个节点能索引的范围更大更精确。由于B树的节点都存了 key 和 data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次 IO 里面，能读出的索引值更多，从而减少查询时候需要的IO次数。

- B+ 树是基于 B 树和**叶⼦节点顺序访问指针**进⾏实现，它具有 B 树的平衡性，并且通过顺序访问指针来提⾼**范围查询**的性能。

### 15. 红黑树和哈希表的区别

- **有序性：**红黑树是有序的，Hash是无序的。
- **搜索效率：**红黑树查找和删除的时间复杂度都是`O(logN)`，Hash查找和删除的时间复杂度都是`O(1)`，由于是通过哈希函数实现，所以Hash的查找效率在一般情况下与数据量无关，而红黑树则不同。

- **内存消耗：**红黑树占用的内存更小（仅需要为其存在的节点分配内存），而 Hash 事先应该分配足够的内存存储散列表，即使有些槽可能弃用，如果分配内存小导致哈希冲突情况增多，如果使用开链法解决冲突，过长的链表导致效率下降。

### 16. unordered_set, unordered_map 的底层实现原理

​	底层使用 hashtable + buket 的实现原理，hashtable 可以看作是一个数组或者 vector 之类的连续内存存储结构，它可以通过下标来快速定位时间复杂度为 O(1) 处理。其 hash 冲突的方法就是在相同 hash值的元素位置下面挂 buket（桶），桶使用链表结构实现。

![unordered_map](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/C/unordered_map.jpg)

### 17. 哈希函数的实现原理

​	哈希法又称散列法、杂凑法以及关键字地址计算法等，相应的表称为哈希表。这种方法的基本思想是：首先在**元素的关键字 *k* 和元素的存储位置 *p* 之间建立一个对应关系 *f* ，**使得*p=f(k)*，*f*称为哈希函数。创建哈希表时，把关键字为 *k* 的元素直接存入地址为 *f(k)* 的单元；以后当查找关键字为 *k* 的元素时，再利用哈希函数计算出该元素的存储位置 *p=f(k)* ，从而达到按关键字直接存取元素的目的。

### 18. 哈希冲突的解决方法

​	**哈希冲突**：由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。

**解决哈希冲突的方法：**

1. **开放定址法：**从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。
   1. **线性探查法**是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，**依次判断下一个单元是否为空**，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。
   2. **线性步长探测法**是在线性探查法的基础上将探测步长从 1 该无 Q，依次判断找到空闲地址。
2. **拉链法：**链接地址法的思路是**将哈希值相同的元素构成一个同义词的单链表**，并将单链表的头指针存放在哈希表的第 i 个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。
3. **再哈希法：**就是同时构造多个不同的哈希函数，当 H1 发生冲突时，再用 H2 计算哈希值，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

### 19. 怎么实现哈希扩容

​	`rehash()` 函数重建hash表，将插槽的数量扩展的 n，如果 n 小于目前插槽数量，这个函数并不起作用。

### 20. sort 方法的底层原理

​	sort 算法的底层主要是快速排序和插入排序结合实现的。数据量大时采用快速排序进行分段递归排序，一旦分段后的数据两小于某个门槛，为了避免快排的递归调用带来的过大负荷，就改用插入排序。如果快排分割行为恶化为`O(N^2)`时间复杂度时，将导致递归层次过深，此时则改用堆排序。

## 07 C++ 11 新特性

### 1. 没有垃圾回收机制会产生什么问题

没有垃圾回收机制会带来了很多内存资源管理不当的问题，例如：

- **野指针**-指向了内存资源已经被释放的空间并被继续使用；
- **重复释放内存**-内存资源在已经被释放的情况下，被试图再次释放导致程序崩溃；
- **内存泄漏**-没有及时释放不再使用的内存资源，致使程序运行过程中占用的内存资源不断累加，最终导致程序崩溃。

### 2. 野指针和悬空指针的区别

- 野指针：**未初始化的指针**被称为野指针

- 悬空指针：当指针所**指向的对象已经被释放**，但是该指针没有任何改变，以⾄于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬空指针

### 3. 什么是智能指针

​	智能指针是⼀个RAII类模型，⽤于动态分配内存，其设计思想是将基本类型**指针封装为（模板）类**对象指针，并在离开作用域时**调用析构函数**，使用 delete 删除指针所指向的内存空间。

​	智能指针的作⽤是，能够处理内存泄漏问题和空悬指针问题。

### 4. 常用的智能指针有哪几种

- **shared_ptr** ：实现**共享式**拥有的概念，即**多个智能指针可以指向相同的对象**，该对象及相关资源会在其所指对象不再使用之后，⾃动释放与对象相关的资源；

- **unique_ptr** ：实现**独占式**拥有的概念，同一时间只能有一个智能指针可以指向该对象，不可以进⾏拷⻉构造和拷⻉赋值，但是可以进⾏移动构造和移动赋值；
- **weak_ptr** ：解决 shared_ptr 相互引用时，两个指针的引⽤计数永远不会下降为0，从而导致死锁的**循环引用问题**。⽽ weak_ptr 是对象的一种弱引⽤，**可以绑定到 shared_ptr ，但不会增加对象的引⽤计数**。

### 5. shared_ptr 的实现原理

​	C++ 智能指针底层是采用**引用计数的方式实现**的。简单的理解，智能指针在**申请**堆内存空间的同时，会为其配备一个整形值（初始值为 1）；每当有**新对象使用**此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象**被释放**时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。

### 6. weak_ptr是如何解除shared_ptr循环引用的

​	**循环引用的问题：**shared_ptr 所管理的对象形成环状的引用，该被调用的析构函数没有被调用，其引用计数无法抵达 0 ，而存在内存泄漏的情况。

 	weak_ptr 可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。形成环状引用的一个对象使用 weak_ptr 对象构造就可以打破循环，析构顺序是weak_ptr 对象被优先析构。

### 7. shared_ptr 和 weak_ptr 是线程安全的吗

​	shared_ptr 的引用计数在实现上是遵循**原子性**的，所以是线程安全的。

### 8. shared_ptr 和 weak_ptr 指向的对象是线程安全的吗

​	但是智能指针其**指向对象的读写**则不是线程安全的。shared_ptr 包含两个主要数据成员，一个是指向对象的指针，一个是引用计数管理对象。当智能指针发生拷贝的时候，先拷贝的是指针，然后拷贝引用计数，这两个操作并不是原子操作，所以无法保证其指向对象的线程安全。

### 9. Lambda 表达式是闭包的吗

​	**闭包**就是能够读取其他函数内部变量的函数

​	首先 lambda 表达式是无状态的，因为lambda表达式的本质是函数，它的作用就是在给定输入参数的情况下，输出固定的结果。

​	如果 lambda 表达式中**引用的方法了的局部变量**，则 lambda 表达式就变成了闭包，因为这个时候lambda表达式是有状态的。

### 10. Lambda 表达式的实现原理

​	**当编写了一个lambda之后，编译器将该表达式翻译成一个匿名类的匿名对象**。**该类含有一个重载的函数调用运算符**。

​	使用 Lambda 表达式可以减少程序中函数对象类的数量

​	就向一些临时变量一样，也存在临时函数的情况。有些简单函数或函数对象在整个程序中可能只需要被调用或使用一次。这样一次性的函数，如果为其单独声明函数或者编写一个类，可能降低程序的可读性。而C++11中提供的 Lambda 表达式提供了避免这一问题的方法，使用 Lambda 表达式构建匿名函数。

### 11. 什么是右值引用

​	右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据；**有名称的、可以获取到存储地址的表达式即为左值；反之则是右值**。

​	C++11中提出了右值引用使用`&&`表示，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。**提出右值引用的主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数**。

### 12. 什么是移动语义

​	STL.中一个 vector 对象管理的动态内存中的元素数量是会变得，**当分配的内存不够存放对象时，就要重新分配一块更大的内存，然后把原来的对象挪到新的内存中放着，再把原来的内存中的元素挨个销毁，最后将原来的内存空间释放**。

​	这个过程包含**开辟新空间、拷贝数据、释放旧空间**，这个繁琐的过程既然旧空间要被释放，如果不是需要开辟更大的空间，那么新对象直接接管旧空间将极大的提高性能。

​	移动语义就是**当原对象拷贝后要就立即被销毁，则此时使用移动而非拷贝对象会大幅提高性能，前提是此类型的对象可以移动。**（移动就是把指针拷贝一下，然后将原来的指针置为空）

https://blog.csdn.net/m0_43436602/article/details/112199418

### 13. 移动操作的条件

- **移动后源对象必须可正常析构：**从一个对象移动数据并不会销毁此对象，但有时在移动操作后，源对象会被摧毁，故我们必须确保，移后源对象处于一个可析构的状态，即析构这个对象不会对移动构造的新对象造成任何影响——例如string的移动，将移后源对象的指针成员置为空，来避免析构的时候把交出去的内存给释放了。
- **移动操作还必须保证移后源对象仍然是有效的：**对象有效就是仍然可以为其赋值，且对象可以安全的使用。虽然我们保证移后源对象是有效的，但其中留下的值并无要求（值是多少都有可能，这依赖于类型设计者是怎么设计的），故我们在程序中不应再使用移后源对象。

### 14. 拷贝构造函数和移动拷贝构造函数的区别

​	移动构造函数传入的参数是一个**右值引用用&&标出**。一般来说左值可以通过使用std:move方法强制转换为右值。

​	拷贝构造函数是先将传入的参数对象**进行一次深拷贝**，再传给新对象。这就会有一次拷贝对象的开销，并且进行了深拷贝，就需要给对象分配地址空间。

​	而移动构造函数就是为了解决这个**拷贝开销**而产生的。移动构造函数首先将传递参数的内存地址空间接管，然后**将内部所有指针设置为nullptr**，并且**在原地址上进行新对象的构造**，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。

​	对于指针参数来讲，需要注意的是，移动构造函数是对**传递参数进行一次浅拷贝**。也就是说如果参数为指针变量，进行拷贝之后将会有两个指针指向同一地址空间，这个时候如果前一个指针对象进行了析构，则后一个指针将会变成野指针，从而引发错误。**所以当变量是指针的时候，要将指针置为空**，这样在调用析构函数的时候会进行判断指针是否为空，如果为空则不回收指针的地址空间，这样就不会释放掉前一个指针。

