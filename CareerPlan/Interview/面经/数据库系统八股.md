## 数据库系统基础概念

### 1. 关系型数据库与非关系型数据库的区别



### 2. 什么是数据库索引

​	索引是为了提⾼数据的查询效率，就像书的⽬录⼀样。减少磁盘 IO 次数

​	同样索引也会带来很多负面影响：

- 创建索引和维护索引需要耗费时间，这个时间随着数据量的增加⽽增加；
- 索引需要占⽤物理空间，不光是表需要占⽤数据空间，每个索引也需要占用物理理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

### 3. 可以用于实现索引的常用数据结构有哪些

​	索引的数据结构和具体存储引擎的实现有关,，在 MySQL 中使⽤较多的索引有 Hash 索引、B+树索引等。经常使⽤的 InnoDB 存储引擎的默认索引实现为 B+ 树索引。

### 4. B 树和 B+ 树的区别

1. B+ 树是基于 B 树和**叶⼦节点顺序访问指针**进⾏实现，它具有 B 树的平衡性，并且通过顺序访问指针来提⾼**范围查询**的性能。
2. 在 B+ 树中，⼀个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key[i] 和 key[i+1]，且不为 null，则该指针指向节点的所有 key ⼤于等于 key[i] 且小于等于 key[i+1]。
3. 进⾏查找操作时，⾸先在根节点进⾏⼆分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进⾏查找。直到查找到叶⼦节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。
4. 插⼊、删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进⾏⼀个分裂、合并、旋转等操作来维护平衡性。

### 5. 为什么用 B+ 树不用 B 树

​	用 B+ 树而不用 B 树考虑的是 IO 对性能的影响，B 树的每个节点都存储数据，⽽ B+ 树只有叶⼦节点才存储数据，所以查找相同数据量的情况下，B 树的**⾼度更高**，**IO 更频繁**。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐⼀加载每⼀个磁盘页（对应索引树的节点）。

### 6. **聚簇索引和非聚簇索引的区别**

​	聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序⼀致。⼀般情况下主键会默认创建聚簇索引，且⼀张表只允许存在⼀个聚簇索引。

​	**聚簇索引和⾮非聚簇索引的区别：**

​	聚簇索引的叶⼦节点就是数据节点，⽽⾮聚簇索引的叶⼦节点仍然是索引节点，只不过有指向对应数据块的指针。

### 7. 什么是事务，它有什么特性

​	数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作**要么全部执行，要么全部不执行**，是一个不可分割的工作单位。

**事务的四大特性：**

- 原子性：原子性是指包含事务的操作要么全部执行成功，要么全部失败回滚。 
- 一致性：一致性指事务在执行前后状态是一致的。 
- 隔离性：一个事务所进行的修改在最终提交之前，对其他事务是不可见的。 
- 持久性：数据一旦提交，其所作的修改将永久地保存到数据库中。 

### 7. 什么是脏读、幻读和不可重复读

当多个事务并发执行时，可能会出现以下问题：

- 脏读：事务A更新了数据，但还没有提交，这时事务B读取到事务A更新后的数据，然后事务A回滚了，事务B读取到的数据就成为脏数据了。 
- 不可重复读：事务A对数据进行多次读取，事务B在事务A多次读取的过程中执行了更新操作并提交了，导致事务A多次读取到的数据并不一致。 
- 幻读：事务A在读取数据后，事务B向事务A读取的数据中插入了几条数据，事务A再次读取数据时发现多了几条数据，和之前读取的数据不一致。 
- 丢失修改：事务A和事务B都对同一个数据进行修改，事务A先修改，事务B随后修改，事务B的修改覆盖了事务A的修改。 

​    不可重复度和幻读看起来比较像，它们主要的区别是：在**不可重复读**中，发现数据不一致主要是**数据被更新**了。在**幻读**中，发现数据不一致主要是**数据增多或者减少**了。

### 7. 数据库的隔离级别

- 未提交读：一个事务在提交前，它的修改对其他事务也是可见的。 
- 提交读：一个事务提交之后，它的修改才能被其他事务看到。 
- 可重复读：在同一个事务中多次读取到的数据是一致的。 
- 串行化：需要加锁实现，会强制事务串行执行。

| 隔离级别 |  脏读  | 不可重复读 |  幻读  |
| :------: | :----: | :--------: | :----: |
| 未提交读 |  允许  |    允许    |  允许  |
|  提交读  | 不允许 |    允许    |  允许  |
| 可重复读 | 不允许 |   不允许   |  允许  |
|  串行化  | 不允许 |   不允许   | 不允许 |

​	**MySQL的默认隔离级别是可重复读**

## MySQL

### 1. MySQL 的锁机制

​	当数据库有并发事务的时候，**保证数据访问顺序**的机制称为锁机制。

| 隔离级别 |                   实现方式                   |
| :------: | :------------------------------------------: |
| 未提交读 |         总是读取最新的数据，无需加锁         |
|  提交读  | 读取数据时加共享锁，**读取数据后**释放共享锁 |
| 可重复读 | 读取数据时加共享锁，**事务结束**后释放共享锁 |
|  串行化  |   锁定整个范围的键，一直持有锁直到事务结束   |

### 2. MVCC 是什么

​	多版本并发控制（MVCC）是一种⽤来**解决读-写冲突**的⽆锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存⼀个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。

​	在并发读写数据库时，可以做到在读操作时不⽤阻塞写操作，写操作也不用阻塞读操作，提⾼了数据库并发读写的性能；同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

### 3. MySQL 的行锁和表锁

- 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发⽣锁冲突的概率最高，并发量最低。
- 行级锁：开销大，加锁慢，会出现死锁。锁定粒度小，发⽣锁冲突的概率小，并发量最高。

### 4. MySQL 共享锁和排他锁（读写锁）

- 共享锁：共享锁又称读锁，简写为S锁，一个事务对一个数据对象加了S锁，可以对这个数据对象进行读取操作，但不能进行更新操作。并且在加锁期间其他事务只能对这个数据对象加S锁，不能加X锁。 
- 排他锁：排他锁又称为写锁，简写为X锁，一个事务对一个数据对象加了X锁，可以对这个对象进行读取和更新操作，加锁期间，其他事务不能对该数据对象进行加X锁或S锁。

## Redis

### 1. 什么是 Redis

Redis 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。

Redis 可以以键值对的形式作为一种 NoSql 数据库，因为 Redis 将所有数据都存放在**内存**中，所以其可达到的数据**读写性能**非常惊人。

除了性能惊人，Redis还具备**可持久化**的特点，它可以将内存中的数据利用快照和日志的形式保存到磁盘上。另外，Redis还提供了键过期，发布订阅，事务，流水线等其他功能。

### 2. Redis 的特性

\1. 读写速度块

\- Redis将所有数据都存放在内存中

\- Redis使用C语言编写，接近底层硬件性能好

\- Redis使用单线程架构，减少CPU切换的性能消耗，也不用考虑锁的问题

\2.  支持多种数据结构

\- 基于键值对的数据结构服务器

\- 支持数据结构：字符串（strings）， 哈希表（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）等

\3. 功能丰富，可扩展性强

\- Redis提供键过期功能，可以实现缓存

\- Redis提供发布订阅功能，可以作为消息系统

\- Redis提供管道Pipeline功能，客户端可以将一批命令一次性传到Redis中，减少网络开销

\4. 简单稳定

\- 代码简单，开源版本中代码行仅在5万行左右

\- 处理模型简单，采用单线程模型，所以使得Redis服务端处理模型变得简单

\- 不依赖操作系统中的任何类库，独立性好

\5. 可持久化

\- RDB方式

\- AOF方式

\6. 主从复制

\7. 高可用和分布式

\- Redis哨兵

\- Redis集群

### 3. Redis 的应用场景

|    支撑功能    |              应用场景              |
| :------------: | :--------------------------------: |
|   键过期功能   |   缓存session会话，缓存mysql数据   |
| 列表，有序集合 |   热度排名排行榜，发布时间排行榜   |
|      集合      |    共同好友，共同兴趣，广告投放    |
|     计数器     | 文章浏览量，视频播放量，评论留言量 |
|    发布订阅    |   消息队列系统，缓存ELK日志收集    |

### 4. Redis 的持久化方式

Redis 提供了不同级别的持久化方式:

- **RDB持久化方式** 能够在指定的时间间隔能对数据进行快照存储
- **AOF持久化方式** 记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据。AOF命令以redis协议追加保存每次写的操作到文件末尾。

### 5. 什么是缓存雪崩、缓存穿透和缓存击穿

​	下图是一个正常的系统架构图，其中缓存的作用是**减轻数据库的压力，提升系统的性能**，无论是缓存雪崩、缓存击穿还是缓存穿透都是缓存失效了导致数据库压力过大。

![redis缓存](/home/wang/Desktop/TechStack/CareerPlan/Interview/面经/DB/redis缓存.png)

​	**缓存雪崩**：缓存雪崩是指在**某一个时刻**出现**大规模**的缓存失效的情况，大量的请求**直接打在数据库上**面，可能会导致数据库宕机，如果这时重启数据库并不能解决根本问题，会再次造成缓存雪崩。

​	**缓存击穿**：缓存雪崩是大规模的 key 失效，而缓存击穿是一个**热点**的 Key，有大并发集中对其进行访问，突然间这个Key失效了，导**致大并发全部打在数据库上**，导致数据库压力剧增，这种现象就叫做缓存击穿。

​	**缓存穿透**：缓存穿透是指用户的请求**没有经过缓存**而直接请求到数据库上了，比如用户请求的key在Redis中不存在，或者用户恶意伪造大量不存在的 key 进行请求，都可以**绕过缓存**，导致数据库压力太大挂掉。

### 6. 缓存雪崩的解决方法

​	缓存雪崩是同一时刻出现大规模的缓存失效导致的，其成因主要有两种情况：（1）**Redis 整体宕机**导致缓存失效；（2）多个 key 被设置了相同的**过期时间**。

​	针对上述成因可以提供如下解决方案：

- 为避免 Redis 宕机造成缓存雪崩，可以搭建 Redis 集群，提高缓存可靠性
- 尽量不要设置相同的过期时间，可以在原有的过期时间加上随机数

### 7. 缓存击穿的解决方法

​	缓存击穿是大量并发请求集中访问的热点 Key 突然缓存失效，而其失效的最直接原因可能是 **key 过期**，所以可以延长或不设置热点 Key 的过期时间，避免其过期失效。

### 8. 缓存穿透的解决方法

​	缓存穿透是用户请求不存在的数据，导致缓存不命中直接请求数据库。这种情况的成因可能是：（1）Redis 确实不存在请求的 Key；（2）用户恶意请求大量不存在的 Key

​	针对上述成因可以提供如下解决方案：

- 缓存空值：如果某个 Key 在Redis和数据库中都不存在，则把该 Key 存入 Redis 并将值置为空值
- 参数校验：对用户 Id 进行校验，拦截不合法的用户请求
- 布隆过滤器：判断 Key 是否存在，如果判断不存在那么一定不存在；如果判断存在，并不能保证一定存在。

### 9. 布隆过滤器的实现原理

多个哈希函数的值查询结果都是 1 才表示数据存在，只要有一个 0 就不存在。

哈希函数个数越多，误判概率越低。

[Redis面试八股](https://www.nowcoder.com/discuss/848513?source_id=profile_create_nctrack&channel=-1)

