## 算法分析与设计 动态规划

### 动态规划引例

​	在如下图的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或右下走。只需求得最大路径和，三角形的行数大于 1 小于等于 100 ，数字为 0~99。

<img src="D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\07DynamicProgramming\数字三角形.jpg" alt="数字三角形" style="zoom:50%;" />

**分析问题**：

​	使用二维数组存放数组三角形，`D[r][j]` 表示第r行第j个数字，`MaxSum(r,j)` 表示从 `D[r][j]` 到底边的各条路径中，最佳路径的数字之和。

​	可以看出这是一个递归定义的问题，从`D[r][j]`出发下一步只能走`D[r+1][j]`或者`D[r+1][j+1]`，则对于有N行的数字三角形有如下递推公式：
$$
MaxSum(r,j)=\left\{\begin{matrix}D[r][j],r=N\\Max(MaxSum(r+1,j),MaxSum(r+1,j+1)+D[r][j],other\end{matrix}\right.
$$

#### 递归实现

```cpp
int maxSumR(vector<vector<int>> arr, int i, int j){
    if(i==arr.size()-1){
        return arr[i][j];
    }
    int x = maxSumR(arr,i+1,j);
    int y = maxSumR(arr,i+1,j+1);
    return max(x,y)+arr[i][j];
}
```

​	递归实现存在的缺陷就是在数字三角形中需要深度遍历每条路径，这其中存在大量的重复计算。则该算法的事时间复杂度为$O(2^n)$，算法性能较低。

#### 存储化实现

​	如果每算出一个`MaxSum(r,j) `就保存起来，下次碰到相同的计算，用到其值的时候直接取用，则可免去重复计算。由于因为三角形的数字总数是 `n(n+1)/2`，这种方式的时间复杂度为$O(n^2)$。

```cpp
vector<vector<int>> maxSumRes(5,vector<int>(5,-1)); // 声明一个5行5列元素全为-1的二维数组
int maxSumStorage(vector<vector<int>> arr, int i, int j){
    // arr[i][j]的路径值已经被计算过
    if(maxSumRes[i][j] != -1){
        return maxSumRes[i][j];
    }
    // arr[i][j]的路径值没有被计算过，递归进行计算
    if(i == arr.size()-1){
        maxSumRes[i][j] = arr[i][j];
    }else{
        int x = maxSumStorage(arr,i+1,j);
        int y = maxSumStorage(arr,i+1,j+1);
        maxSumRes[i][j] = max(x,y) + arr[i][j];
    }
    return maxSumRes[i][j];
}
```

#### 非递归实现

​	从存储化实现过程中，可以思考直接用二维表存储路径值，数字三角形自下而上递推也可以快速计算出最大路径值，如下图所示：

<img src="D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\07DynamicProgramming\数字三角形.png" alt="数字三角形" style="zoom:48%;" />

```cpp
vector<vector<int>> maxSumRes2D(5,vector<int>(5,0));
int maxSum2D(vector<vector<int>> arr){
    for(int j = 0; j < arr[arr.size()-1].size();++j){
        maxSumRes2D[arr.size()-1][j] = arr[arr.size()-1][j];
    }
    for(int i = arr.size()-2;i>=0;--i){
        for(int j=0;j<=i;++j){
            maxSumRes2D[i][j] = max(maxSumRes2D[i+1][j],maxSumRes2D[i+1][j+1]) + arr[i][j];
        }
    }
    return maxSumRes2D[0][0];
}
```

​	从递推表中可以看出，每一行 manSum 路径值在被使用只有不在重复使用，所以可以直接覆盖，没必要用二维 maxSum 数组存储每一个 `MaxSum(r,j)`, 只要从底层一行行向上递推，那么只要一维数组即可,即只要存储一行的 `MaxSum` 值就可以。

```cpp
vector<int> maxSumRes1D(5,0); 
int maxSum1D(vector<vector<int>> arr){
    for(int j = 0; j < arr[arr.size()-1].size();++j){
        maxSumRes1D[j] = arr[arr.size()-1][j];
    }
    for(int i = arr.size()-2;i>=0;--i){
        for(int j=0;j<=i;++j){
            maxSumRes1D[j] = max(maxSumRes1D[j],maxSumRes1D[j+1]) + arr[i][j];
        }
    }
    return maxSumRes1D[0];
}
```

​	同理，可以进一步考虑，数字三角形中的元素被使用之后也不再重复使用，所以连一维数组都可以不要创建，直接用数字三角形二维数组的第 n 行进行覆盖，替代 maxSum 一维数组即可。

### 动态规划的一般思路

​	递归问题一般都可以转化为动规求解：递归函数有 n 个参数，就定义一个 n 维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始，逐步由已知推未知填充数组，相当于计算递归函数值的逆过程。

​	递归问题的优点在于程序编写简单且直观，而缺点就是可能会因递归层数太深导致爆栈，函数调用带来额外时间开销。 **无法使用滚动数组节省空间** ，总体来说，比动规效率慢。

#### 动态规划解题的一般思路

​	确定重叠的子问题；得到最小子问题的解；用表来保留额外信息减少重复计算；描述状态转移，表达解之间的关系；用小问题的解逐步构造原问题的解。

1. **将原问题分解为子问题**

* 利用**分治策略**，把原问题分解为若干个子问题，子问题被进一步划分为更小的子问题；直到划分为容易解决的原子问题，得到平凡解。子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决后，原问题随即解决。
* 划分过程中可能包含大量重复的问题，可以利用**存储化**的思想，利用表来存储已解决的子问题的解，遇到相同的子问题，只需在表中查找答案，所以每个子问题只需求解一次。

2. **确定状态**

* 动态规划中，往往将和子问题相关的各个变量的一组取值，称之为一个**状态**。一个状态对应于一个或多个子问题，所谓某个**状态下的值**，就是这个状态所对应的子问题的解。
* 所有状态的集合，构成问题的**状态空间**。状态空间的大小，与用动态规划解决问题的时间复杂度直接相关。在数字三角形的例子里，一共有 $N × (N+1)/2$ 个数字，所以这个问题的状态空间里一共就有 $N × (N+1)/2$ 个状态。**整个问题的时间复杂度是状态数目乘以计算每个状态所需时间**。在数字三角形里每个状态只需要经过一次，且在每个状态上作计算所花的时间都是和 N 无关的常数。
* 在动态规划中经常碰到的情况是，K 个整型变量能构成一个状态（如数字三角形中的行号和列号这两个变量构成状态）。如果这 K 个整型变量的取值范围分别是$N1, N2, ……Nk$，那就可以用一个 K 维的数组`array[N1] [N2]……[Nk]`来存储各个**状态的值**。这个值未必就是一个整数或浮点数，可能是需要一个结构才能表示的，那么 array 就可以是一个结构数组。一个状态下的值通常会是一个或多个子问题的解。

3. **确定初始状态的值**

* 以数字三角形问题为例，初始状态就是底边数字，值就是底边数字值可任意直接填入到状态值存储表中。初始状态通常都可以认为是问题的平凡解。

4. **确定状态转移方程**

* 定义出问题的状态，以及在该状态下的值后，就要找出不同的状态之间如何迁移的，即如何从一个或多个值已知的状态，求出另一个状态的值的**递推型** 。状态的迁移可以用递推公式表示，此递推公式也可被称作状态转移方程。
* 例如数字三角形问题的状态转移方程为：

$$
MaxSum(r,j)=\left\{\begin{matrix}D[r][j],r=N\\Max(MaxSum(r+1,j),MaxSum(r+1,j+1)+D[r][j],other\end{matrix}\right.
$$

#### 动态规划适用问题的特点

* **问题具有最优子结构性质**：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构性质。
* **无后效性**：当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。

### 最长上升子序列

​	一个数的序列 $a_i$ ，当 $a_1 < a_2 < ... < a_S$ 的时候，称这个序列是上升的。对于给定的一个序列 $(a_1 , a_2 , ..., a_N)$，可以得到一些上升的子序列$ (a_{i1} , a_{i2} , ..., a_{iK})$，其中$1 <= i1 < i2 < ... < iK<= N$ 。例如，对于序列 (1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如 (1, 7), (3, 4, 8) 等等。这些子序列中最长的长度是 4 ，例如子序列 (1, 3, 5, 8).你的任务。对于给定任意序列，求出其最长上升子序列的长度。

**分析问题**

1. **找重叠的子问题**：

   ​	一种子问题的分解方法是“求序列的前 n 个元素的最长上升子序列的长度“，但是这种定义方法不具有**无后效性**,，不满足无后效性是无法写出**递推公式**的。无法由前 n 个元素的最长上升子序列的长度**推导**得出前 n+1 个元素的最长上升子序列的长度。

   ​	例如，$F(n)=x$，n 个元素组成的序列是其**状态**，而这 n 个元素的最长上升子序列的长度$x$，是这多种状态都可以到达的**状态的值**，多对一关系。但是对于$F(n+1)=?$ ，n+1个元素可能有多种状态，而$F(n+1)$的取值与$F(n)$的**状态**有关，这个状态的序列最后一个元素比$a_{n+1}$小，则可以形成更长的最长上升子序列，反之则不行。这种子问题定义方式**下一个状态的值**与前一个状态相关而不是和**前一个状态所到达的值**相关，所以不具有**无后效性**。

   ​	另一种子问题的分解方法“求以 $a_k, (k=1, 2, 3…N)$为终点的最长上升子序列的长度”。一个上升子序列中最右边的那个数，称为该子序列的**终点**。虽然这个子问题和原问题形式上并不完全一样，但是只要这 N 个子问题都解决了，那么这 N 个子问题的解中，最大的那个就是整个问题的解。

2. **确定状态**：

   ​	子问题只和一个变量，即**数字的位置**相关。因此，在序列中数字的位置 k 就是**状态**，而状态 k 对应的**值**，就是以 $a_k$ 做为终点的最长上升子序列的长度，状态一共有 N 个。

3. **确定状态转移方程**：

   ​	`maxLen(k)` 表示以 $a_k$ 做为终点的最长上升子序列的长度那么，可以得到如下递推公式：
   $$
   MaxLen(k)=\left\{\begin{matrix}1,k=1\\Max(MaxLen(i),1<=i且a_i<a_k且k!=1)+1,other\end{matrix}\right.
   $$
   ​	`maxLen(k)` 的值，就是在$a_k$左边，终点数值小于$a_k$ ，且长度最大的那个上升子序列的长度再加 1 。因为$a_k$左边任何终点小于$a_k$的子序列，加上$a_k$后就能形成一个更长的上升子序列。

```cpp
int maxLen(vector<int> arr){
    vector<int> maxLenRes(arr.size(),1);
    for(int k=1;k<arr.size();++k){
        for(int i=0;i<k;++i){
            if(arr[k]>arr[i]){
                maxLenRes[k] = max(maxLenRes[k],maxLenRes[i]+1); // 以ak为终点的子序列的长度为已记录最大长度和新长度中的较大值
            }
        }
    }
    // 输出 maxLenRes 中的最大值
    vector<int>::iterator max = max_element(maxLenRes.begin(),maxLenRes.end());
    return *max;
}
```

### 最长公共子序列

​	给出两个字符串，求出这样的一个最长公共子序列的长度，子序列中的每个字符都能在两个原串中找到，而且每个字符的先后顺序和原串中的先后顺序一致。

**分析问题**

1. **找重叠的子问题**：

   ​	一种子问题的分解方法是“对于两个序列s1和s2，求s1前 i 个字符组成的子序列与s2前 j 个字符组成的子序列的最长公共子序列的长度“。

2. **确定状态**：

   ​	设`MaxLen(i,j)`表示的是 s1 的左边 i 个字符形成的子串，与 s2 左边的 j 个字符形成的子串的最长公共子序列的长度，则$MaxLen(i,j)$就是本题的**状态**。

3. **确定状态转移方程**：

   $MaxLen(i,j)$ 表示s1 的左边 i 个字符形成的子串，与 s2 左边的 j 个字符形成的子串的最长公共子序列的长度，那么，可以得到如下递推公式：

$$
MaxLen(i,j)=\left\{\begin{matrix}0,i=0或j=0\\MaxLen(i-1,j-1)+1,s1[i-1]=s2[j-1]\\Max(MaxLen(i,j-1),MaxLen(i-1,j)),s1[i-1]!=s2[j-1]\end{matrix}\right.
$$

​	$MaxLen(i,j)$  的值分三种情况：

* 如果s1或s2为空串，那么值为0
* 如果s1的第i个字符和s2的第j个字符**相等**，则$MaxLen(i,j)$ 的值为s1左边i-1个字符组成的子序列与s2左边j-1个字符组成的子序列的最长公共子序列的长度**+1**，即$MaxLen(i-1,j-1)+1$
* 如果s1的第i个字符和s2的第j个字符**不相等**，$MaxLen(S1,S2)$ 不会比 $MaxLen(S1,S2_{j-1})$
  和$MaxLen(S1_{i-1},S2)$, 两者之中任何一个小，也不会比两者都大。则其取值为$Max(MaxLen(i,j-1),MaxLen(i-1,j))$

```cpp
int lcs(string s1,string s2){
    // s1 或 s2 为空串的情况下两者的公共子序列为 0
    vector<vector<int>> maxLen(s1.length()+1,vector<int>(s2.length()+1));
    // s1,s2 均为非空
    for(int i=1;i<=s1.length();++i){
        for(int j=1;j<=s2.length();++j){
            if(s1[i-1]==s2[j-1]){
                maxLen[i][j] = maxLen[i-1][j-1] + 1;
            }else{
                maxLen[i][j] = max(maxLen[i][j-1],maxLen[i-1][j]);
            }
        }
    }
    return maxLen[s1.length()][s2.length()];
}
```

### 简单背包问题

​	有一个背包的总容积是 40 ，用这个背包装东西为了不让背包破，这些物品的总体积必须是 40 。现在有 n 个物品，每个物品的体积分别是 $a_1,a_2,…a_n$ 。 从这些物品中选择一些，如果选出的物体的总体积是 40 就可以放入背包袋，求有多少种不同的选择物品的方式。

**分析问题**

1. **找重叠的子问题**：

​	一种子问题的分解方法是“选择第k个物品，则在减去第k个物品体积的剩余空间中再选剩下k-1物品中的一个；不选择第k个物品，则不改变现有空间大小在k-1物品中选择物品“。

2.  **确定状态**：

​	设`Ways(w,k)`表示的是背包空间为w，可选物品为k的情况下选择物品的方法数量，$Ways[w][k]$​就是本题的**状态**。

3. **确定状态转移方程**：

   $Ways[w][k]$表示的是背包空间为w，可选物品为k的情况下选择物品的方法数量，那么，可以得到如下递推公式：
$$
Ways[w][k]=\left\{\begin{matrix}1,w=0\\0,k<0\\Ways[w][k-1],不选第k个物品\\Ways[w][k]+Ways[w-a[k]][k-1],选择第k个物品\end{matrix}\right.
$$
​	$MaxLen(i,j)$  的值分三种情况：

* 如果w刚好等于0，说明一种物品选择方法形成；如果k<0说明物品体积不够，无法形成一种方法
* 如果不选第k个物品，则不影响总的方法数量
* 如果选择第k个物品，则方法总数等于当前总数加上减去选择k物品之后剩余空间和物品的选择方法总数

```cpp
//递归实现
int simpleKnapRcu(vector<int> arr, int w, int k){
    if(w == 0) return 1;
    if(k < 0) return 0;
    return simpleKnapRcu(arr,w,k-1)+simpleKnapRcu(arr,w-arr[k],k-1);
}

//动规实现
int simpleKnapDyn(vector<int> arr, int weight, int num){
    vector<vector<int>> ways(weight+1,vector<int>(num+1));
    for(int i=1;i<num+1;++i){
        ways[0][i] = 1;
    }
    ways[0][0] = 1;
    for(int w=1; w<=weight; ++w){
        for(int k=1; k<=num; ++k){
            ways[w][k] = ways[w][k-1];
            if(w-arr[k]>=0){ // arr[k] 输入数组索引要与k值一致
                ways[w][k] += ways[w-arr[k]][k-1];
            }
        }
    }
    return ways[weight][num];
}
```

### 0-1背包问题

​	有 N 件物品和一个容积为 W 的背包。第 i 件物品的体积 w[i]，价值是 d[i] 。求解在总重量不超过上限 W 的情况下，将哪些物品装入背包可使价值总和最大。每种物品只有一件，0-1决策可以选择放或者不放。

1. **找重叠的子问题**：

​	一种子问题的分解方法是“选择第k个物品，则在减去第k个物品体积的剩余空间中再选剩下k-1物品中的一个；不选择第k个物品，则不改变现有空间大小在k-1物品中选择物品“。

2.  **确定状态**：

​	设`F[i][j]`表示的是取前 i 种物品，使它们总体积不超过 j 的最优取法取得的价值总和，则$F[i][j]$​就是本题的**状态**。

3. **确定状态转移方程**：

  $F[i][j]$表示的是取前 i 种物品，使它们总体积不超过 j 的最优取法取得的价值总和，$v[i],w[i]$分别表示第i个物品的价值和体积，那么，可以得到如下递推公式：
$$
F[i][j]=\left\{\begin{matrix}v[1],i=1且w[1]<=j\\0,w[1]>j\\max(F[i-1][j],F[i-1][j-w[i]]+v[i]),选择第i个物品\end{matrix}\right.
$$
​	$F[i][j]$  的值分两种情况：

* 边界情况：只有一个物品，如果所剩空间足够方这个物品，则$F[1][j]=v[1]$ ，否则$F[1][j]=0$ 
* 递推情况：取或不取第 i 种物品，两者选优，当所剩空间大于等于0是才能选择放入物品，即$j-w[i]>=0$

```cpp
vector<vector<int>> F(100,vector<int>(100,0));
int zoKnapsack(vector<int> w, vector<int> v, int num, int vol){
    for(int i=1;i<=num;++i){
        for(int j=1;j<=vol;++j){
            F[i][j] = F[i-1][j];
            if(j-w[i]>=0){
                F[i][j] = max(F[i-1][j],F[i-1][j-w[i]]+v[i]);
            }
        }
    }
    return F[num][vol];
}
```

