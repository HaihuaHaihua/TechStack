## 算法分析与设计 Catlan数

### Catlan数基本概念

​	卡特兰数（Catalan number）是 **组合数学** 中一个常出现在各种 **计数问题** 中的 **数列**。数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，...

​	catlan数的通项如下：
$$
C_1=1,C_n= \frac{ C_{2n}^{n}}{n+1}= C_{n-1}\frac{2(2n-1)}{n+1}= C_{2n}^{n}- C_{2n}^{n-1}
\\C_{n}^{m}=\frac{n!}{m!(n-m)!}
$$
​	可以用如上递推公式来求得第n个 catlan 数

### 路径问题

​	要从网格的左下角移动到右上角，其中只能经过有点的位置，一次只能**向上或向右**移动一个网格，且不能对角移动，如下图所示，左图为非法路径，右图为合法路径。求一共有多少种从左下角到右上角的移动路径。

<img src="D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\08Greedy\路径问题.jpg" alt="路径问题" style="zoom:50%;" />

**分析问题**：

​	若网格是nxn的，那么从左下角移动到右上角一共需要移动2n步。假设当前已经完成了k步，那么这k步一定合法，接下来还要走2n - k步，也必须合法。

​	所有可以如下分解问题：先从$(0,0)$走到$(i,n − i), i ≤ n − i$，再从$(i, n − i)$到$(n,n)$, 初始值$Ct(0,0)=1$
$$
Ct(i,j)=\left\{\begin{matrix}Ct(i,j-1),i=0\\Ct(i-1,j),i=j\\Ct(i-1,j)+Ct(i,j-1),i<j\end{matrix}\right.
$$

```cpp
int Ctl (int i, int j)
{
	if (1 == i && 1 == j) // base case
		return (1);
	if (i < j && i > 1 && j > 1)
		return (Ctl (i - 1, j) + Ctl (i, j - 1));
	if (i == j) // diagonal
		return (Ctl (i - 1, j));
	if (i == 1) // border
		return (Ctl (i ,j - 1));
	printf (" Should ␣have ␣not␣ reached ␣here\n");
	return (0);
}
```

### 出栈顺序问题

​	n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列。

**分析问题**：

​	这个问题可以和上述路径问题类比，在n × n的方格中，**入栈=向上**，**出栈=向右**，起点(0,0)，终点(n,n)。

​	我们将进栈表示为 +1，出栈表示为 -1。根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的 **所有前缀和** 必然大于等于 0，并且 +1 的数量 **等于** -1 的数量。

​	接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。如果将 **第一个** 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

​	因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1个 -1 的序列。

​	假设非法序列为 A，对应的序列为 B。每个 A 只有一个**第一个前缀和小于 0 的前缀**，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到**第一个前缀和大于 0 的前缀**，显然 B 也只能产生一个 A。

​	每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为$C_{2n}^{+1n}$ ，相当于在长度为 2n 的序列中找到`n + 1`个位置存放 +1。相应的，非法序列的数量也就等于$C_{2n}^{n+1}$。

​	出栈序列的总数量共有$C_{2n}^{n}$  ，因此，合法的出栈序列的数量为$C_{2n}^{n}- C_{2n}^{n-1}$



### 满二叉树结点数量

​	`n + 1` 个叶子节点能够构成多少种形状不同的满二叉树

**分析问题**：

​	满二叉树定义：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

​	使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。`n + 1`个叶子结点会有 2n 次扩展，构成$\frac{ C_{2n}^{n}}{n+1}$种形状不同的满二叉树。





### 二叉树数量问题

​	给定二叉树的中序遍历结果：1,2,3,...,n；求一共有多少种不同的二叉树可能产生这种中序遍历。

**分析问题**：

​	二叉树的中序遍历就是首先遍历左子树，然后访问当前结点，最后遍历右子树。可见二叉树中序遍历的根节点出现在中部，那么就可以分解出子问题：假设根结点为$i+1$，则左子树由左边$i$个结点组成，右子树由$n-i-1$个结点组成，而左子树和右子树是递归定义的。

```cpp
int count(int n){
    int sum = 0;
    // n==0时形成一个二叉树
    if(n==0){
        return(1);
    }
    for(int i=0;i<n;i++){
        sum+=count(i)*count(n-i-1);
    }
    return(sum);
}
```

