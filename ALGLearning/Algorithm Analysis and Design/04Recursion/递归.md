## 算法分析与设计 递归

### 递归的基本概念

·	递归是指在函数的定义中调用函数自身，一个经典的例子就是用递归函数求阶乘

```cpp
int factorial(int n){
    if(n == 0){
        return 1;
    }else{
        return n * factorial(n-1);
    }
}
```

​	从上例可以看出**递归的基本思想**就是把规模大的问题拆解为规模小的相同的子问题来解决，且在这个不断拆解为更小问题的过程中有一个临界点，即问题拆解的**终止条件**。当达到临界点时，从被拆解的最小问题的解开始返回答案，累积得到原问题的解。

​	所以在递归函数实现时，包含了两部分，一个是**递归主体**，另一个是**终止条件**。因为大问题和小问题是一样的问题，因此大问题的解决方法和小问题的解决方法也是同一个方法这就是递归主体。这种函数调用它自身的情况，必须有明确的终止条件，否则就会导致无限递归。

​	总的来说，递归问题的求解关键在于找出问题转化的递推公式和终止条件，递推公式来自将大问题拆解为小问题的规律，终止条件就是问题的平凡解，即问题的最简单情况。

​	**递归的作用**：

* 替代多重循环
* 解决本来就是用递归形式定义的问题
* 将问题分解为规模更小的子问题进行求解

### 汉诺塔问题

​	有一个梵塔，塔内有三个座 A 、 B 、 C，A 座上有 64 个盘子，盘子大小不等，大的在下，小的在上。 现在想把这 64 个盘子从 A 座移到 B 座，但每次只能允许移动一个盘子，并且在移动过程中， 3 个座上的盘子始终保持大盘在下，小盘在上 。 在移动过程中可以利用 C 座，要求移动的步骤。

<img src="D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\04Recursion\汉诺塔.jpg" alt="汉诺塔" style="zoom:40%;" />

**分析问题**：

* 初始情况：将圆盘按大小顺序堆放在 A 上，最大的在底部
* 移动规则：允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的上面
* 最终目标：以最少的移动次数将所有圆盘从 A 转移到 B
* 终止条件：A 只有一个盘子，直接将它从 A 移动到 B
* 递推规律：先将 n-1 个盘子从 A 移动到中转 C，再将最大的一个盘子移动到 B，然后将 n-1 个盘子从 C 移动到 B

```cpp
#include<iostream>
using namespace std;

void hanoi(int n, char src, char mid, char dest){
    if(n == 1){
        cout << src << "->" << dest << endl;
        return; // 终止条件
    }
    hanoi(n-1, src, dest, mid); // 将 n-1 个盘子从 src 移到 mid 柱
    cout << src << "->" << dest << endl; // 将 src 柱的最大盘移到 dest 柱
    hanoi(n-1, mid, src, dest); // 将 n-1 个盘子从 mid 移到 dest 柱
}

int main(){
    int n = 3;
    hanoi(n,'A','C','B');
    return 0;
}
```

