## 算法分析与设计 贪心算法

### 贪心算法基本概念

​	贪心算法的策略是每一步行动总是按某种指标选取最优的操作来进行，该指标只看眼前，并不考虑以后可能造成的影响。也就是说，不考虑整体上的最优解，它所做出的仅仅是在某种意义上的**局部最优解**。贪心算法是不稳定的，所以需要证明其正确性。

​	贪心算法的关键：找到合适的数学模型来描述问题，把问题分解成几个小的部分，对每一个部分进行求解，得到子问题的局部最优解，最后把子问题的局部最优解组合在一起形成原问题的解。

### 作业调度问题

​	作业调度是一个典型的一个调度竞争共享资源的多活动问题，这种问题的目标是选出一个最大的互相兼容的活动集合。给定 n 个作业和一台机器，作业$i$有一个开始时间$s_i$和一个完成时间$f_i$，其中$f_i>=s_i$。对于任意两个计划作业$i$和$j$，有$f_i<=s_j或f_j<=s_i$，即两个作业的工作时间不重叠则称这两个活动是**兼容的**。求以非重叠的方式找到可以在机器上调度的最大作业子集。

**分析问题**：

​	假设使用$S_{ij}$表示在作业$i$结束之后开始，在作业$j$开始之前结束的作业集合。假定整体最优解中包含作业$k$，则可以将问题划分为两个子问题：找出$S_{ik}$和$S_{kj}$。

​	一个简单的思路是将所有作业按结束时间从小到大排序，第一步选结束时间最早的那个作业。 然后，每步都选和上一个选中的作业不冲突且结束时间最早的作业。

```cpp
#include<iostream>
#include<vector>
#include<map>
#include<algorithm>

using namespace std;

class job{
    public:    
    int id;
    int startT;
    int endT;
    job(int i=0,int s=0 , int e=0){id=i;startT=s;endT=e;}
    friend void jobSche(vector<job> arr, vector<int>& res);
    friend void jobSortByEndT(vector<job>& arr, int start, int end);
    friend void swap(job& ja, job& jb);
};

void swap(job& ja, job& jb){
    job tmp;
    tmp.id = ja.id;tmp.startT=ja.startT;tmp.endT=ja.endT;
    ja.id = jb.id;ja.startT=jb.startT;ja.endT=jb.endT;
    jb.id = tmp.id;jb.startT=tmp.startT;jb.endT=tmp.endT;
}

void jobSortByEndT(vector<job>& arr, int start, int end){
    if(start>=end) return;
    int pHead=start; int pTail=end;
    int key=arr[start].endT;
    while(pHead<pTail){
        while (pTail>pHead&&arr[pTail].endT>=key)
        {
            pTail--;
        }
        swap(arr[pHead],arr[pTail]);
        while (pHead<pTail&&arr[pHead].endT<=key)
        {
            pHead++;
        }
        swap(arr[pHead],arr[pTail]);
    }
    jobSortByEndT(arr,start,pHead-1);
    jobSortByEndT(arr,pTail+1,end);
}

void jobSche(vector<job> jobs, vector<int>& res){
    jobSortByEndT(jobs,0,jobs.size()-1);
    res.push_back(jobs[0].id);
    int target = jobs[0].endT;
    for(int i=1;i<jobs.size();++i){
        if(jobs[i].startT>=target){
            res.push_back(jobs[i].id);
            target = jobs[i].endT;
        }
    }
}

int main(){
    vector<int> startTime{6,1,2,3,5,3,0,5,8,8,12};
    vector<int> endTime{11,4,14,5,7,9,6,9,10,12,16};
    vector<job> jobs;
    for(int i=1;i<=endTime.size();++i){
        job j(i,startTime[i-1],endTime[i-1]);
        jobs.push_back(j);
    }
    vector<int> res;
    jobSche(jobs,res);
    for(int i=0;i<res.size();++i){
        cout << res[i] << ',';
    }
    return 0;
}
```

### 最佳股票交易时间

​	整型数组中的元素表示当天股票的价格，设计一个算法来计算所能获取的最大利润。根据需要买入卖出，完成尽可能多的交易，不得同时进行多笔交，必须在再次购买之前卖出股票。

**分析问题**：

​	从上帝视角看每一次涨跌就可以产生利润，这样每一次涨跌就是一个子问题，在低点买入，在高点卖出，低点是指股票较前一天下跌的点，高点是指较前一天上涨的点。这样的短线频繁操作的最优解最终形成最大利润。

```cpp
int stock(vector<int> arr){
    int profit = 0;
    for(int i=1;i<arr.size();++i){
        if(arr[i]>arr[i-1]){
            profit += arr[i]-arr[i-1];
        }
    }
    return profit;
}
```

### Dijkstra最短路径算法

​	给定一个带权图以及其起点和终点，求起点到终点之间的最短路径。如下图所示，以A点为起点，F点为终点，求A到F的最短路径。

<img src="D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\08Greedy\Dijkstra.jpg" alt="Dijkstra" style="zoom:35%;" />

​	**Dijkstra的算法思想**是一种贪婪策略，算法贪婪地探索从s开始的路径，每次移动到下一个最近的节点，通过这种方式实际上构造了从s到图中每个其他节点的最短路径。即从上述最短距离数组中每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。

​	更加形式化的表达如下：

* 对于图$G=(V,E,W),V={A,B,C,D,E,F},s=A,t=F$

* 初始化确定集合$K=\{s\},Path(s)=\varnothing,d(s)=0$
* 对于所有不在K中的结点$i\in (V-K)$，计算距离$d(i) = min\{d(u)+w(u,i)\},u \in K$  
* 选择$d(i)$中最小的值对应的结点，将其加入到K中，并修改不属于K的结点到K中结点的最小距离

```cpp
const int infinity = 99999;

void dijkstra(vector<vector<int>> G, vector<int>& res){
    int points = G.size();
    vector<int> dist(points);
    vector<bool> flag(points,false);
    res = dist;
    // 起点 初始化被选集
    flag[0] = true;
    for(int i=0;i<points;++i){
        dist[i] = G[0][i];
    }
    // 寻找最短路径
    for(int i=1;i<points-1;++i){
        int min = infinity;
        int u = -1;
        for(int j=0;j<points;++j){
            // 比较离原点最近的点
            if(!flag[j]&&dist[j]<min){
                u = j;
                min = dist[j];
            }
        }
        // 找出最近点之后，更新最短距离
        flag[u] = true;
        for(int j=1;j<points;++j){
            if(!flag[j]&&(dist[u]+G[u][j]<dist[j])){
                dist[j] = dist[u] + G[u][j];
                res[j] = u;
            }
        }
    }
}
```

### 最小生成树问题

参考链接：https://blog.csdn.net/Africa_South/article/details/88608619

​	一个连通图的生成树是一个极小连通子图，它含有图中全部的顶点，但是只有足有构成一棵树的n-1条边。它有如下性质：

* 一棵有n个顶点的生成树有且只有n − 1条边；
* 如果一个图有n个顶点和小于n − 1条边，则是非连通图；如果它多于n − 1条边，则一定有环；
* 但是有n − 1条边的n个顶点的图不一定是生成树。（它只是必要条件）

​    一棵生成树的代价就是树上各边的代价之和。

​	最小生成树就是构造连通图的最小代价生成树，简称为**最小生成树**。

#### Prim算法

![prim](D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\08Greedy\prim.png)



#### Kruskal算法

![kruskal](D:\01BasicLearning\TechnicalRoute\ALGLearning\Algorithm Analysis and Design\08Greedy\kruskal.jpg)

