## LeetCode刷题笔记 动态规划

### 01 一维动态规划



### 02 二维动态规划



### 03 分割型动态规划



### 04 子序列问题

​	对于子序列问题，第一种动态规划方法是，定义一个 `dp` 数组，其中 `dp[i] `表示以 i 结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。

#### [300 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给定一个未排序的整数数组，求最长的递增子序列。

输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。

>```
>输入：nums = [10,9,2,5,3,7,101,18]
>输出：4
>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
>```

**解析:**

​	在本题中，`dp[i]` 可以表示以 i 结尾的、最长子序列长度。对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则我们可以获得一个以 i 结尾的、长度为 `dp[j] + 1` 的子序列。为了遍历所有情况，我们需要 i 和 j 进行两层循环，其时间复杂度为 O(n^2)。

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int len = nums.size();
        // 将所有位置初始化为 1, 因为len>=1,所以最短递增子序列就是 1 
        vector<int> dp(len,1); 
        int ans = 1;
        // i 控制每一个记录位置
        for(int i=1;i<len;++i){ 
            // j 扫描 i 之前的子序列
            for(int j=0;j<i;++j){ 
                // 如果出现递增情况，判断是否增加的子序列长度
                if(nums[i]>nums[j]){ 
                    dp[i] = max(dp[i],dp[j]+1);
                }
            }
            // 完成一个位置的记录之后，判断是否是较大长度
            ans = max(ans,dp[i]);
        }
        return ans;
    }
};
```

#### [1143 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串，求它们最长的公共子序列长度。

输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。

>```
>输入：text1 = "abcde", text2 = "ace" 
>输出：3  
>解释：最长公共子序列是 "ace" ，它的长度为 3 。
>```

**解析:**

​	对于子序列问题，第二种动态规划方法是，定义一个 `dp `数组，其中 `dp[i]` 表示到位置 i 为止的子序列的性质，**并不必须以 i 结尾**。这样 `dp` 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。
​	在本题中，我们可以建立一个二维数组 `dp`，其中 `dp[i][j]` 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。从1开始计算字符串位置，那么当`text1` 的第 i 个字符与 `text2` 的第 j 个字符相等时，其最长公共子串长度为前一状态加1，即 `dp[i][j] = dp[i-1][j-1] + 1`；如果不相等，`dp[i][j]` 不会比`dp[i-1][j]` 和`dp[i][j-1]` 两者之中任何一个小，也不会比两者都大，即 `dp[i][j] = max(dp[i-1][j],dp[i][j-1])`

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int len1 = text1.length(), len2 = text2.length();
        // 创建len+1行len2+1列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度
        vector<vector<int>> dp(len1+1,vector<int>(len2+1));
        for(int i=1;i<=len1;++i){
            for(int j=1;j<=len2;++j){
                // 相等情况
                if(text1[i-1]==text2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                // 不等情况
                }else{
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
};
```

### 05 背包问题

​	背包问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为完全背包问题。

​	0-1 背包问题，我们可以定义一个二维数组 `dp` 存储最大价值，其中 `dp[i][j]` 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，分为两种情况：（1）如果我们不将物品 i 放入背包，即当前背包容量不足或这放入当前物品无法达到最大价值，那么 `dp[i][j]= dp[i-1][j]`，即前 i 个物品的最大价值等于只取前 i -1 个物品时的最大价值；（2）如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 `dp[i][j] = dp[i-1][j-w] + v`。

```cpp
int knapsack(vector<int> weights, vector<int> values, int N, int W) {
	vector<vector<int>> dp(N+1,vector<int>(W+1));
    // 放置第i个物品
    for(int i=1;i<=N;++i){
        // 第 i 个物品的体积w和价值v
        int w = weights[i-1], v = values[i-1];
        // 遍历容量
        for(int j=1;j<=W;++j){
            if(j>=w){
                dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);
            }else{
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[N][W];
}
```

​	在完全背包问题中，一个物品可以拿多次。这里直接给出完全背包问题的状态转移方程`dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)`，其与 0-1 背包问题的差别**仅仅**是把状态转移方程中的第二个 i-1 变成了 i。

```cpp
int knapsack(vector<int> weights, vector<int> values, int N, int W) {
	vector<vector<int>> dp(N+1,vector<int>(W+1));
    // 放置第i个物品
    for(int i=1;i<=N;++i){
        // 第 i 个物品的体积w和价值v
        int w = weights[i-1], v = values[i-1];
        // 遍历容量
        for(int j=1;j<=W;++j){
            if(j>=w){
                dp[i][j] = max(dp[i-1][j],dp[i][j-w]+v);
            }else{
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[N][W];
}
```

#### [416 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。

输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。

> ```
> 输入：nums = [1,5,11,5]
> 输出：true
> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。
> ```

**解析:**

​	本题等价于 0-1 背包问题，设所有数字和为 sum，我们的目标是选取一部分物品，使得它们的总和为 target = sum/2，及用部分物品填满容量为target的背包。同时本题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。

​	设置状态： `dp[i][j]` 表示 nums 的前 i 个整数是否能够组合成和为 j

​	状态转移方程：(01背包问题的子问题都很简单只用区分选择当前物品或者不选择当前物品的情况)

* 不选择 `nums[i]`：`nums[i]` 大于于当前容量 j 时，容量不够不选择该物品，`dp[i][j] = dp[i-1][j]`

* 选择 `nums[i]`：

  > * `nums[i]` 恰好等于当前容量 j，即`nums[i]==j`时，只放该物品就可以填满容量为 j 的背包，`dp[i][j] =true`
  > * `nums[i]` 小于当前容量 j，即`nums[i]<j`时，只放该物品不够填满容量为 j 的背包，检测放入该物品后`dp[i-1][j-nums[i]]`的情况下是否可以填满背包
  >
  > 总的说，当容量足够时，物品nums[i] 可选可不选（在有价值的情况下就需要选择价值较大的情况），则`dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]`

​    初始情况：容量为0的时候，不选择任何物品，`dp[i][0] = true`；只有一个物品的时候，当容量为`j == nums[0]`时恰好满足，即`dp[0][nums[0]] = true`

​	示例的状态转移矩阵根据上述状态转移方程可以得到如下表格：

|          |   0   |   1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |
| :------: | :---: | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| [0] = 1  | **T** | **T** |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |  F   |
| [1] = 5  | **T** |   T   |  F   |  F   |  F   |  T   |  T   |  F   |  F   |  F   |  F   |  F   |
| [2] = 11 | **T** |   T   |  F   |  F   |  F   |  T   |  T   |  F   |  F   |  F   |  F   |  T   |
| [3] = 5  | **T** |   T   |  F   |  F   |  F   |  T   |  T   |  F   |  F   |  F   |  T   |  T   |

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = accumulate(nums.begin(),nums.end(),0);
        auto maxPos = max_element(nums.begin(),nums.end());
        int target = sum/2, len = nums.size();
        // 注意特殊情况，和为奇数或者元素个数小与2都无法进行有效分割，而元素值大于target直接导致越界
        if(len<2 || sum&1 || *maxPos > target){
            return false;
        }
        vector<vector<bool>> dp(len,vector<bool>(target+1,false));
        // 初始情况容量为0
        for(int i=0;i<len;++i){
            dp[i][0] = true;
        }
        // 初始情况物品只有一个
        dp[0][nums[0]] = true;
        for(int i=1;i<len;++i){
            for(int j=1;j<=target;++j){
                // 背包容量大于当前扫描物品，可选可不选
                if(j >= nums[i]){
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                // 背包容量小于当前扫描物品，没法选
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[len-1][target];
    }
};
```

#### [474 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

​	给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。

​	输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。

> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
> 输出：4
> 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

**解析：**

​	本题也是一个01背包问题，而其特点在于它有两个背包，一个装0，另一个装1。

​	设置状态：`dp[i][j][k]` 表示装0背包容量为 j，装1背包容量为k的情况下，能够装入前 i 个物品中的几个

​	状态转移方程：仍旧划为装入当前物品和不装入当前物品两个子问题，不装入则`dp[i][j][k]=dp[i-1][j][k]`，装入则`dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w0[i]][k-w1[i]] + 1)`，其中w0表示物品中0的体积，w1表示物品中1的体积。

```cpp
class Solution {
public:

    // 计算每个str中0和1的数量
    pair<int,int> countWeight(string str){
        int count0 = 0, count1 = 0;
        for(int i=0;i<str.length();++i){
            if(str[i] == '0'){
                ++count0;
            }else{
                ++count1;
            }
        }
        return make_pair(count0,count1);
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        // 用一个三维数组表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量
        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));
        for(int i=1;i<=len;++i){
            auto count = countWeight(strs[i-1]);
            // j 和 k 都从零开始，因为str存在'0'或'1'这种只有一种元素构成的情况
            for(int j=0;j<=m;++j){
                for(int k=0;k<=n;++k){
                    if(j >= count.first && k >= count.second){
                        dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count.first][k-count.second] + 1);
                    }else{
                        dp[i][j][k] = dp[i-1][j][k];
                    }
                }
            }
        }
        return dp[len][m][n];
    }
};
```

#### [322 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

​	给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。

​	输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。	

> ```
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
> ```

**解析：**

​	因为每个硬币可以用无限多次，这道题本质上是完全背包问题。完全背包问题还是没搞懂，记录一下，以后仔细琢磨。

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int Max = amount + 1;
        vector<int> dp(amount + 1, Max);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i) {
            for (int j = 0; j < (int)coins.size(); ++j) {
                if (coins[j] <= i) {
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
```

### 06 字符串编辑问题

#### [72 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

​	给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。

​	输入是两个字符串，输出是一个整数，表示最少的步骤。

> 输入：word1 = "horse", word2 = "ros"
> 输出：3
> 解释：
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')

**解析：**

​	本题与最长公共子序列类似，两个字符串的对比所以需要使用一个二维数组来设置状态 `dp[i][j]`

​	设置状态：`dp[i][j]` 表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。

​	状态转移方程：当第 i 位和第 j 位对应的字符相同时，`dp[i][j]` 等于 `dp[i-1][j-1]`；当二者对应的字符不同时，修改的消耗是 `dp[i-1][j-1]+1`，插入 i 位置/删除 j 位置的消耗是 `dp[i][j-1] + 1`，插入 j 位置/删除 i 位置的消耗是 `dp[i-1][j] + 1`，所以在不同的情况下状态转移方程`dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])`。

​	边界情况：word1为空串时，需要插入字符与word2一致，即`dp[0][j] = j`；同理，word2为空串是`dp[i][0] = i`

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.length(), n = word2.length();
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        // 边界条件 word2为空串
        for(int i=0;i<=m;++i){
            dp[i][0] = i;
        }
        // 边界条件 word1为空串
        for(int j=0;j<=n;++j){
            dp[0][j] = j;
        }
        for(int i=1;i<=m;++i){
            for(int j=1;j<=n;++j){
                // 状态转移，相等情况不编辑，不等情况选择编辑次数最少的编辑
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;
                }
            }
        }
        return dp[m][n];
    }
};
```

#### [650 只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

​	给定一个字母 A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。

​	输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。

> 输入：3
> 输出：3
> 解释：
> 最初, 只有一个字符 'A'。
> 第 1 步, 使用 Copy All 操作。
> 第 2 步, 使用 Paste 操作来获得 'AA'。
> 第 3 步, 使用 Paste 操作来获得 'AAA'。

**解析：**

​	不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。

​	设置状态：使用一个一维数组 `dp[i]`，其中位置 i 表示延展到长度 i 的最少操作次数。

​	状态转移方程：对于每个位置 j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到，其操作次数等价于把一个长度为 1 的 A 延展到长度为 i/j。例如3由1操作得到`A A A`，6由2操作得到`AA AA AA`因此可以得到递推公式 `dp[i] = dp[j] + dp[i/j]`。

```cpp
class Solution {
public:
    int minSteps(int n) {
        vector<int> dp(n+1);
        for(int i=2;i<=n;++i){
            dp[i] = i;
            for(int j=2;j<=i;++j){
                if(i%j==0){
                    dp[i] = dp[j] + dp[i/j];
                    break;
                }
            }
        }
        return dp[n];
    }
};
```

#### [10 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

​	给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配，其中`'.'` 匹配任意单个字符；`'*'` 匹配零个或多个前面的那一个元素。

​	输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。

> 输入：s = "aab" p = "c*a*b"
> 输出：true
> 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

**解析：**

​	两个字符串进行匹配，且字符具有特殊含义，本题动态规划的特点在于多种情况下的不同状态转移方程。

​	设置状态：使用一个布尔类型的二维数组 dp，其中 `dp[i][j]` 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。

​	状态转移方程：根据正则表达式的不同情况，即字符、星号，点号，分情况讨论来更新 dp 数组

* 相等情况：即`s[i-1] == p[j-1] || p[j-1] == '.'`的情况，这种情况下`dp[i][j] == dp[i-1][j-1]`，即与前 i-1 个子串匹配情况一致

* 不相等情况：

  > * `s[i-1] != p[j-1] && p[j-1] != '*'` ，直接不匹配情况`dp[i][j] = false`
  > * `p[j-1] != '*'`：如果匹配0次则`dp[i][j-2] == true` 则 `dp[i][j] = true`；如果匹配多次则需要验证`'*'`前一个字符相等情况即`s[i-1] == p[j-1] || p[j-1] == '.'`，相等则`dp[i][j] = dp[i-1][j]`，否则不匹配

​    初始情况：空串匹配非空正则表达式，`dp[0][0]=true`，当`p[j-1]=='*'`是可以匹配0次匹配空串即`dp[0][j] =dp[0][j-2]`；非空串匹配空正则表达式，`dp[0][0]=true`，其他情况都无法成功匹配。

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));
        dp[0][0] = true;
        for(int j=1;j<=n;++j){
            if(p[j-1] == '*'){
                dp[0][j] = dp[0][j-2];
            }
        }

        for(int i=1;i<=m;++i){
            auto chs = s[i-1]; 
            for(int j=1;j<=n;++j){
                auto chp = p[j-1];
                if(chs == chp || chp == '.'){
                    dp[i][j] = dp[i-1][j-1];
                }else if(chp ==  '*'){
                    if(j>1){
                        if(dp[i][j-2]){
                            dp[i][j] = true;
                        }else{
                            auto prechp = p[j-2];
                            if(prechp==chs || prechp =='.'){
                                dp[i][j] = dp[i-1][j];
                            } 
                        }
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```

### 07 股票交易问题



