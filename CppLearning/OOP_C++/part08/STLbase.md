## C++ 标准模板库 STL 概述

### 泛型程序设计

**C++ 的特点**：

​	C++ 的核心优势之一就是便于软件重用，而软件的重用在 C++ 中主要体现在以下两个方面：

* 面向对象的思想：继承、多态和标准类库
* 泛型程序设计的思想：模板机制和标准模板库 STL

**泛型程序设计**：

​	泛型程序设计通俗地讲就是使用**模板**的程序设计方法。泛型程序设计中将一些常用的**数据结构**（例如链表、数组和二叉树等）和**算法**（例如排序和查找等）写成模板，这样在后续的使用中不管数据结构中存放的是什么数据对象，算法应用于什么类型的数据对象，都不需要重新实现数据结构和算法，极大的提高了代码重用性。

​	标准模板库 *(Standard Template Library)* 就是最为常用的数据结构和算法的**模板集合**，使用 STL 可以直接重用大多的标准数据结构和算法，而且能够获得相对较高的性能。

### STL 中的基本概念

**容器**：可容纳各种数据类型的通用**数据结构**，都是**类模板**：

**迭代器**：可用于依次存取容器中的元素，类似**指针**

**算法**：用来操作容器中元素的**函数模板**，例如可以使用 `sort()` 来对一个 *vector* 中的数据进行排序，使用 `find()` 来搜索一个 *list* 中的对象。算法的实现和它操作的数据对象无关，所以可以将算法应用于几乎任何数据结构。

```cpp
int array[100]; // 容器
int* parr = array; // 使用 int* 类型的指针变量作为迭代器
sort(parr, parr+70); // 使用 sort() 算法作用于该容器
```

### 容器

​	容器是可容纳各种数据类型（基本数据类型、对象等）的通用**数据结构**，都是**类模板**，分为三种类型：

* **顺序容器**：*vector, deque, list*  
* **关联容器**：*set, multiset, map, multimap* 
* **容器适配器**：*stack, queue, priority_queue*

​    使用容器时需要注意两点：

* 对象被插入容器中时，被插入的是对象的一个**复制品**
* 有些容器本身是存在顺序关系的即是**已排序的**，所以放入容器的对象所属的类一般需要重载 **==** 和 **<** 运算符。 

**顺序容器**：

​	顺序容器是**非排序的**，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。

* *vector* `#include <vector>` 一维动态数组：其元素在内存中是**连续存放**的，随机存取任何元素都可以在常数时间内完成，在该容器的**尾部**增删元素也几乎能够在常熟时间内完成具有较好的性能。
* *deque* `#include <deque>` 双向队列：其元素在内存中是**连续存放**的，随机存取任何元素都可以在常数时间内完成，在该容器的**两端**增删元素也几乎能够在常熟时间内完成具有较好的性能。
* *list* `#include <list>` 双向链表：其元素在内存中是**不连续存放**的，不支持随机存取，在该容器的**任何位置**增删元素几乎都能够在常熟时间内完成具有较好的性能。

**关联容器**：

​	关联容器的元素是**排序的**，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用**平衡二叉树**实现，其插入和检索的时间都是 $O(log(N))$ 。

* *set/multiset* `#include <set>` 集合：*set* 集合中**不允许**存在相同的元素，*multiset* 集合中**允许**存在相同的元素。
* *map/multimap* `#include <map>` 键值对集合：*map* 和 *set* 的不同在于前者存放的元素有且仅有两个成员变量 `(first,second)`，一个名为 `first`，另一个名为 `second` ，`first` 的值用来对整体元素进行从小到大的排序，并可以通过 `first` 快速检索元素。和 *multiset* 类似 *multimap* 和 *map* 的区别中**允许**存在相同 `first` 值的元素。

**容器适配器**：

* *stack* `#include <stack>` 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是**最近插入**序列的项，即栈顶的项。满足**后进先出**规则
* *queue* `#include <queue>` 队列：（**入队**）插入只允许在尾部进行，（**出队**）删除、检索和修改只允许在头部进行。满足**先进先出**规则
* *priority_queue* `#include <queue>` 优先级队列：优先级最高的元素总是第一个出队列

**顺序容器和关联容器的成员函数**：

|  成员函数  |                       函数作用                       |
| :--------: | :--------------------------------------------------: |
| `begin()`  |       返回指向容器中第一个元素位置的**迭代器**       |
|  `end()`   | 返回指向容器中最后一个元素**后面**的位置的**迭代器** |
| `rbegin()` |      返回指向容器中最后一个元素位置的**迭代器**      |
|  `rend()`  |  返回指向容器中第一个元素**前面**的位置的**迭代器**  |
| `erase()`  |              从容器中删除一个或几个元素              |
| `clear()`  |                 从容器中删除所有元素                 |

**顺序容器的常用成员函数**：

|   成员函数    |                           函数作用                           |
| :-----------: | :----------------------------------------------------------: |
|   `front()`   |                返回容器中第一个元素的**引用**                |
|   `back()`    |               返回容器中最后一个元素的**引用**               |
| `push_back()` |                     在容器末尾增加新元素                     |
| `pop_back()`  |                      删除容器末尾的元素                      |
|   `erase()`   | 删除**迭代器**指向的元素，或删除一个区间，返回被删除元素后面的那个元素的**迭代器** |

### 迭代器



